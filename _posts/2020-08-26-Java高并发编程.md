---
scrolllayout: post
title:  "Java高并发编程"
date:   2020-08-26 11:02:06 +0800--
categories: [Java]
tags: [高并发,JUC ]  
---

# Java高并发编程

## JUC是什么

java.util.concurrent 在并发编程中使用的工具类

## 进程与线程

**进程**

- 程序由**指令和数据**组成，但这些指令要运行，数据要读写，就必须**将指令加载至 CPU，数据加载至内存**。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理 IO 的**。
- 当一个程序被运行，**从磁盘加载这个程序的代码至内存，这时就开启了一个进程**。
  **进程就可以视为程序的一个实例**。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）。

**线程**

- 通常在**一个进程中可以包含若干个线程**，当然一个进程中至少有一个线程，不然没有存在的意义。
- 线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把**线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度**。

### 线程状态

```java
NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED;
```

![image-20200830104045416](/assets/imgs/image-20200830104045416.png)

### wait/sleep

功能都是当前线程暂停，有什么区别？wait放开手去睡，放开手里的锁sleep握紧手去睡，醒了手里还有锁。

### 并发和并行

**并发**：同一时刻多个线程在访问同一个资源，多个线程对一个点   例子：小米9今天上午10点，限量抢购      春运抢票      电商秒杀...

**并行：**多项工作一起执行，之后再汇总   例子：泡方便面，电水壶烧水，一边撕调料倒入桶中



### Java 线程创建方式

**方法一，直接使用 Thread**

```java
// 创建线程对象
Thread t = new Thread() {
// 重写run方法为业务逻辑
public void run() {
 		System.out.println("Hello MyThread!");
 }
};
// 启动线程
t.start();
```

**方法二，使用 Runnable 配合 Thread**

```java
Runnable runnable = new Runnable() {
public void run(){
 		System.out.println("Hello MyRun!");
 }
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start();
```

**方法三，FutureTask 配合 Thread**

```java
FutureTask<Integer> task3 = new FutureTask<>(() -> {
 System.out.println("Hello");
 return 100;
});
// 参数1 是任务对象; 参数2 是线程名字，推荐
new Thread(task3, "t3").start();
// 主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
System.out.println("结果是: " + result);
```

**Java 8 以后可以使用 lambda 精简代码(推荐)**

```java
new Thread(()->{
    System.out.println("Hello MyThread!");
},"t").start();
```

## Lock接口

锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。

### Lock接口的实现

**ReentrantLock可重入锁**，如何使用：

```java
class X {
  private final ReentrantLock lock = new ReentrantLock();
  // ...
  public void m() {
   lock.lock(); // block until condition holds
   try {
​    // ... method body
   } finally {
​    lock.unlock()
   }
  }
 }
```

### **synchronized与Lock的区别** 

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）

6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。



### 接口里是否能有实现方法

- default方法

- 静态方法实现：接口新增 

## 线程间通信

### 面试题：四个线程打印

> 现在4个线程，可以操作初始值为0的一个变量。实现两个线程对该变量加1，两个线程对该变量减1，实现交替加减10轮。
>
> 1.高内聚低耦合前提下，线程操作资源类
>
> 2.判断/干活/通知
>
> 3.多线程交互中，必须要防止多线程的虚假唤醒，也即(判断只用while，不能用if)

#### synchronized版

![image-20200830172609995](/assets/imgs/image-20200830172609995.png) 

⚠️：if 情况下，同时唤醒了两个+1的线程，并且没有被拉回再次判断导致shareData+1+1。 [code](https://github.com/Silincee/-/blob/master/src/main/java/com/silince/juc/ThreadWaitNotifyDemo.java)

```java
public class ThreadWaitNotifyDemo {
    public static void main(String[] args) {
        ShareData shareData = new ShareData();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A").start();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B").start();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "C").start();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "D").start();
    }

}

class ShareData {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        //1 判断
        while (number != 0) {
            this.wait();
        }
        //2 干活
        number++;
        System.out.println(Thread.currentThread().getName() + ": " + number);
        //3 通知
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        //1 判断
        while (number == 0) {
            this.wait();
        }
        //2 干活
        number--;
        System.out.println(Thread.currentThread().getName() + ": " + number);
        //3 通知
        this.notifyAll();
    }
}
```

#### lock版

![image-20200830173333135](/assets/imgs/image-20200830173333135.png)

[code](https://github.com/Silincee/-/blob/master/src/main/java/com/silince/juc/ThreadWaitNotifyDemo2.java)

```java
class ShareData {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() throws InterruptedException {
        lock.lock();
        try {
            //1 判断
            while (number != 0) {
                condition.await();
            }
            //2 干活
            number++;
            System.out.println(Thread.currentThread().getName() + ": " + number);
            //3 通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            //1 判断
            while (number == 0) {
                condition.await();
            }
            //2 干活
            number--;
            System.out.println(Thread.currentThread().getName() + ": " + number);
            //3 通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



### 面试题：线程间定制化调用通信

> lock的新特性：通过设置多个condition可以实现  ***精准通知 精准唤醒***    [code](https://github.com/Silincee/-/blob/master/src/main/java/com/silince/juc/ThreadOrderAccess.java)
>
> 并发编程口诀：
>
> 1.高内聚低耦合前提下，线程操作资源类
>
> 2.判断/干活/通知
>
> 3.多线程交互中，必须要防止多线程的虚假唤醒，也即(判断只用while，不能用if)
>
> 4.注意标志位的修改和定位

题目：多线程之间按顺序调用，实现A->B->C。三个线程启动，要求如下：

1. AA打印5次，BB打印10次，CC打印15次
2. 按此顺序打印10轮

### 面试题：多线程锁

[code](https://github.com/Silincee/-/blob/master/src/main/java/com/silince/juc/Lock8.java)

```
1. 标准访问，先打印短信还是邮件
   - 邮件
2. 停4秒在短信方法内，先打印短信还是邮件
   - 邮件
3.  普通的hello方法，是先打短信还是hello
   - Hello
4.  现在有两部手机，先打印短信还是邮件
   - 短信
5.  两个静态同步方法，1部手机，先打印短信还是邮件
   - 邮件
6.  两个静态同步方法，2部手机，先打印短信还是邮件
   - 邮件
7. 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件
   - 短信(也不是同一个锁，一个是类一个是实例)
8. 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件
   - 短信
```

#### **synchronized实现同步的基础**

Java中的每一个对象都可以作为锁。具体表现为以下3种形式：

1. 对于普通同步方法，锁是当前实例对象。
2. 对于静态同步方法，锁是当前类的Class对象。
3. 对于同步方法块，锁是Synchonized括号里配置的对象。

#### 详细分析：

1. **锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法。**
   - 一个对象里面如果有多个**synchronized方法**，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，**某一个时刻内，只能有唯一一个线程去访问这些synchronized方法。**

2. **加个普通方法Hello()后发现和同步锁无关。**

3. **换成两个对象后，不是同一把锁了，情况立刻变化。这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。**
   - 也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以无须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。

4. **所有的静态同步方法用的也是同一把锁——类对象本身**
   - 一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！

5. **当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。**











