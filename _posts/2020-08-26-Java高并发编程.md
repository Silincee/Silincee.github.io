---
scrolllayout: post
title:  "Java高并发编程"
date:   2020-08-26 11:02:06 +0800--
categories: [Java]
tags: [高并发,JUC ]  
---

# Java高并发编程

## JUC是什么

java.util.concurrent 在并发编程中使用的工具类

## 进程与线程

**进程**

- 程序由**指令和数据**组成，但这些指令要运行，数据要读写，就必须**将指令加载至 CPU，数据加载至内存**。在指令运行过程中还需要用到磁盘、网络等设备。**进程就是用来加载指令、管理内存、管理 IO 的**。
- 当一个程序被运行，**从磁盘加载这个程序的代码至内存，这时就开启了一个进程**。
  **进程就可以视为程序的一个实例**。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）。

**线程**

- 通常在**一个进程中可以包含若干个线程**，当然一个进程中至少有一个线程，不然没有存在的意义。
- 线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把**线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度**。

### 线程状态

```java
NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED;
```

![image-20200830104045416](/assets/imgs/image-20200830104045416.png)

### wait/sleep

功能都是当前线程暂停，有什么区别？wait放开手去睡，放开手里的锁sleep握紧手去睡，醒了手里还有锁。

### 并发和并行

**并发**：同一时刻多个线程在访问同一个资源，多个线程对一个点   例子：小米9今天上午10点，限量抢购      春运抢票      电商秒杀...

**并行：**多项工作一起执行，之后再汇总   例子：泡方便面，电水壶烧水，一边撕调料倒入桶中



### Java 线程创建方式

**方法一，直接使用 Thread**

```java
// 创建线程对象
Thread t = new Thread() {
// 重写run方法为业务逻辑
public void run() {
 		System.out.println("Hello MyThread!");
 }
};
// 启动线程
t.start();
```

**方法二，使用 Runnable 配合 Thread**

```java
Runnable runnable = new Runnable() {
public void run(){
 		System.out.println("Hello MyRun!");
 }
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start();
```

**方法三，FutureTask 配合 Thread**

```java
FutureTask<Integer> task3 = new FutureTask<>(() -> {
 System.out.println("Hello");
 return 100;
});
// 参数1 是任务对象; 参数2 是线程名字，推荐
new Thread(task3, "t3").start();
// 主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
System.out.println("结果是: " + result);
```

**Java 8 以后可以使用 lambda 精简代码(推荐)**

```java
new Thread(()->{
    System.out.println("Hello MyThread!");
},"t").start();
```

## Lock接口

锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。

### Lock接口的实现

**ReentrantLock可重入锁**，如何使用：

```java
class X {
  private final ReentrantLock lock = new ReentrantLock();
  // ...
  public void m() {
   lock.lock(); // block until condition holds
   try {
​    // ... method body
   } finally {
​    lock.unlock()
   }
  }
 }
```

### **synchronized与Lock的区别** 

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）

6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

***关于 synchronized 的作用域*** ： [synchronized锁住的是代码还是对象](https://blog.csdn.net/xiao__gui/article/details/8188833?utm_source=blogxgwz7&utm_medium=distribute.pc_relevant.none-task-blog-title-5&spm=1001.2101.3001.4242)

- synchronized(this)以及非static的synchronized方法（至于static synchronized方法请往下看），只能防止多个线程同时执行同一个对象的同步代码段。
- synchronized锁住的是括号里的对象，而不是代码。对于非static的synchronized方法，锁的就是对象本身也就是this。
- 所以我们在用synchronized关键字的时候，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要再整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。

- 最后说说static synchronized方法，static方法可以直接类名加方法名调用，方法中无法使用this，所以它锁的不是this，而是类的Class对象，所以，static synchronized方法也相当于全局锁，相当于锁住了代码段。

### 接口里是否能有实现方法

- default方法

- 静态方法实现：接口新增 

## 线程间通信

### 面试题：四个线程打印

> 现在4个线程，可以操作初始值为0的一个变量。实现两个线程对该变量加1，两个线程对该变量减1，实现交替加减10轮。
>
> 1.高内聚低耦合前提下，线程操作资源类
>
> 2.判断/干活/通知
>
> 3.多线程交互中，必须要防止多线程的虚假唤醒，也即(判断只用while，不能用if)

#### synchronized版

![image-20200830172609995](/assets/imgs/image-20200830172609995.png)

⚠️：if情况下，同时唤醒了两个+1的线程，并且没有被拉回再次判断导致shareData+1+1。

```java
public class ThreadWaitNotifyDemo {
    public static void main(String[] args) {
        ShareData shareData = new ShareData();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A").start();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B").start();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "C").start();
        new Thread(() -> {
            // method
            for (int i = 0; i < 10; i++) {
                try {
                    shareData.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "D").start();
    }

}

class ShareData {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        //1 判断
        while (number != 0) {
            this.wait();
        }
        //2 干活
        number++;
        System.out.println(Thread.currentThread().getName() + ": " + number);
        //3 通知
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        //1 判断
        while (number == 0) {
            this.wait();
        }
        //2 干活
        number--;
        System.out.println(Thread.currentThread().getName() + ": " + number);
        //3 通知
        this.notifyAll();
    }
}
```

#### lock版

![image-20200830173333135](/assets/imgs/image-20200830173333135.png)

```java
class ShareData {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() throws InterruptedException {
        lock.lock();
        try {
            //1 判断
            while (number != 0) {
                condition.await();
            }
            //2 干活
            number++;
            System.out.println(Thread.currentThread().getName() + ": " + number);
            //3 通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            //1 判断
            while (number == 0) {
                condition.await();
            }
            //2 干活
            number--;
            System.out.println(Thread.currentThread().getName() + ": " + number);
            //3 通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

