---
scrolllayout: post
title:  "Mysql数据库高级 锁机制"
date:   2020-08-24 21:02:06 +0800--
categories: [数据库]
tags: [mysql, ]  
---

# 锁机制

锁是计算机协调多个进程或线程并发访问某一资源的机制。

在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 锁的分类

1. 从数据操作的类型（读、写）分
   - **读锁**（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响
   - **写锁**（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。
2. 从对数据操作的颗粒度
   - 表锁
   - 行锁

## 表锁（偏读）

***偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低。***

### **案例分析：**

```sql
-- 建表，引擎选择 myisam
create table mylock (
    id int not null primary key auto_increment,
    name varchar(20) default ''
) engine myisam;

insert into mylock(name) values('a');
insert into mylock(name) values('b');
insert into mylock(name) values('c');
insert into mylock(name) values('d');
insert into mylock(name) values('e');

-- 手动加锁和释放锁
lock table 表名1 read(write), 表名2 read(write), ...;
-- 释放表锁
unlock tables;
-- 查看当前数据库中表的上锁情况，0 表示未上锁
show open tables;

-- 在mylock表添加读锁
lock table mylock read;
select * from mylock; -- session1/2 都可读
update mylock set name='a2' where id = 1; -- session1可修改；session2必须等待其读锁释放
select * from book; -- session1不可读其他表；session2可读其他表
```

### **结论：**

1. 当前 session 可以读取但不能修改加了写锁的表；不能读取或修改其他表。
2. 其他 session 想要读取加了写锁的表，必须等待其读锁释放；可以查询或修改其他未锁定的表。

## 行锁（偏写）

**偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。**

**InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁**

### 事务回顾

事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。

#### **事务的ACID属性**

1. **原子性**（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
2. **一致性**（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
3. **隔离性**（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。
4. **持久性**（Durability）：事务院成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

---

#### **并发事务处理带来的问题**

1. 更新丢失（Lost Update）：
   - 当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题一一最后的更新覆盖了由其他事务所做的更新。
   - 例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。
   - 如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。
2. 脏读（Dirty Reads）：
   - 一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读”。
   - ***一句话：事务A读取到了事务B已修改但尚未提交的的数据，还在这个数据基础上做了操作。***此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。
3. 不可重复读（Non-Repeatable Reads）：
   - 一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
   - ***一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性***
4. 幻读（Phantom Reads）
   - 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读一句话：事务A读取到了事务B体提交的新增数据，不符合隔离性。
   - 多说一句：幻读和脏读有点类似，***脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。***

------

#### **事物的隔离级别**

“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

![image-20200824223912977](/assets/imgs/image-20200824223912977.png)

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。

查看当前数据库的事务隔离级别：`show variables like 'tx_isolation';` mysql 默认是可重复读

### 案例分析：

