---
layout: post
title:  "字节码指令集与解析举例"
date:   2020-11-03 22:22:16 +0800--
categories: [JVM,]
tags: [Java, JVM]  

---

[JVM字节码指令手册](http://www.silince.cn/2020/11/03/JVM字节码指令手册/)

# 概述

Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。    

Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode） 以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands） 而构成。由于Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。

***由于限制了Java虚拟机操作码的长度为一个字节（即0~255），这意味着指令集的操作码总数不可能超过256条。***

官方文档: https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html

熟悉虚拟机的指令对于动态字节码生成、反编译Class文件、Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解Java虚拟机的基础技能，需要熟练学握常见指令。



## 执行模型

如果不考虑异常处理的话，那么Java虛拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解。

```java
do{
	自动计算PC寄存器的值加1;
	根据PC寄存器的指示位置，从字节码流中取出操作码;
	if（字节码存在操作数）从字节码流中取出操作数;
	执行操作码所定义的操作;
}while（字节码长度 > 0);
```



## 字节码与数据类型

在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，`iload` 指令用于从局部变量表中加载int型的数据到操作数栈中，而`fload`指令加载的则是float类型的数据。

***对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务:***

- i 代表对 int 类型的数据操作
- l 代表 long 
- s 代表 short
- b 代表 byte
- c 代表 char
- f 代表 float
- d 代表 double

***也有一些指令的助记符中没有明确地指明操作类型的字母***，如`arraylength`指令， 它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。

还有另外一些指令，***如无条件跳转指令goto则是与数据类型无关的。***

大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。⚠️***编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend） 为相应的int类型数据，将boolean和char类 型数据零位扩展（Zero-Extend）为相应的int类型数据。***与之类似，在处理boolean、byte、 short和char 类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、 short 和char类型数据的操作，



## 指令分类

由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。

- 加载与存储指令
- 算术指令
- 类型转换指令
- 对象的创建与访问指令
- 方法调用与返回指令
- 操作数栈管理指令
- 比较控制指令
- 异常处理指令
- 同步控制指令

在做值相关操作时:

- 一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值可能是对象的引用）被压入操作数栈。
- 一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。



# 操作数栈与局部变量表

![image-20201105221753702](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201105221753702.png)

## 操作数栈

我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。

在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟块 额外的空间作为***操作数栈，来存放计算的操作数以及返回结果。***

具体来说便是：***执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。***

![image-20201105213539934](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201105213539934.png)

以加法指令iadd 为例。假设在执行该指令前，栈项的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中。

![image-20201105213557677](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201105213557677.png)

由于iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。



## 局部变量表 

Java方法栈桢的另外一个重要组成部分则是局部变量区，***字节码程序可以将计算的结果缓存在局部变量区之中。***

实际上，Java虚拟机将局部变量区***当成一个数组***，依次存放this指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。

和操作数栈一样，long类型以及double 类型的值将占据两个单元，其余类型仅占据一个单元。

![image-20201105221013794](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201105221013794.png)

## 举例

```java
public void foo(long l,float f){
  {
    int i = 0;
  }
  {
    String s = "Hello,World"; //  槽位复用;i出了作用域，使用s还是在该位置。
  }
}
```

对应图示：

![image-20201105221237300](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201105221237300.png)

在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

在方法执行时，虚拟机使用局部变量表完成方法的传递。



# 加载与存储指令

1.作用  

加载和存储指令用于将数据***从栈帧的局部变量表和操作数栈之间来回传递***。

2.常用指令

- 【局部变量压栈指令】将个局部变量加载到操作数栈:` xload`、` xload<n>` （其中x为i、1、f、d、a，n为日到3）

- 【常量入栈指令】 将一个常量加载到操作数栈: `bipush`、`sipush`、` ldc`、`ldc_W`、`ldc2_W`、`aconst_null`、` iconst_m1`、`iconst<i>`、 `lconst<l>`、` fconst<f>`、` dconst<d>`

- 【出栈装入局部变量表指令】 将一个数值从操作数栈存储到局部变量表: `xstore`、 `xstore<n>` （其中x为i、l、f、d、a，n为0到3）； `xastore` （其中x为i、l、f、d、a、b、c、s）

-  扩充局部变量表的访问索引的指令:  `wide`

  

上面所列举的指令助记符中，有一部分是以尖括号结尾的（ 例如`iload<n>`） 。这些指令助记符实际上代表了一组指令（例如`iload<n>`代表了`iload_0`、`iload_1`、`iload_2`和`iload_3`这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如`iload`）的特殊形式，***对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。***



除此之外，它们的语义与原生的通用指令完全一致（例如`iload_0`的语义与操作数为0时的iload 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，`<n>`代表非负的整数， `<i>`代表是int类型数据，`<1>`代表long类型，`<f>`代表float类型， `<d>` 代表double类型。



## 局部变量压栈指令

***局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。***

这类指令大体可以分为:

- `xload_<n> `（x为i、l、f、d、a，n为0到3）
- ` xload` （x为i、l、f、d、a）

- 说明:在这里，x的取值表示数据类型。

指令`xload_n`表示将第n个局部变量压入操作数栈，比如`iload 1`、 `fload_0`、`aload_0`等指令。其中`aload_n`表示将一个对象引用压栈。

指令`xload`通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令`iload`、`fload`等 。





## 常量入栈指令

常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为const系列、push系列和ldc指令。

指令const系列:用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有:` iconst<i>` （i从-1到5）、`lconst<1> `（1从0到1）、` fconst<f> `（f从0到2）、`dconst<d>` （d从0到1）、`aconst_null`。

比如，

- `iconst_m1`将 -1压入操作数栈；
- `iconst_x` （x为0到5）将x压入栈:
- `lconst_0`、` lconst_1`分别将长整数0和1压入栈:
- `fconst_0`、`fconst_1`、`fconst_2`分别将浮点数0、1、2压入栈:
- `dconst_0`和`dconst_1`分别将double型0和1压入栈。
- `aconst_null`将null压入操作数栈；

从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，l表示长整数，f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。

指令push系列: 主要包括`bipush`和`sipush`。 它们的区别在于接收数据类型的不同，

- `bipush`接收8位整数作为参数
- `sipush`接收16位整数:它们都将参数压入栈。

指令ldc系列: 如果以上指令都不能满足需求，那么可以使用万能的`ldc`指令，它可以接收一个8位的参数， ***该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。***

- 类似的还有`ldc_w`，它接收两个8位参数，***能支持的索引范围大于ldc(索引太大时，自动替换为`ldc_w`)。***

- ***⚠️如果要压入的元素是long或者double类型的，则使用`ldc2_w`指令，使用方式都是类似的。***

总结如下：

![image-20201106094324729](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201106094324729.png)



## 出栈装入局部变量表指令

***出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。***
这类指令主要以store的形式存在，比如`xstore` （x为i、 l、f、d、a）、`xstore_n` （x为i、l、f、d、a，n为0至3）。

- 其中，指令`istore_n`将从操作数栈中弹出一个整数，并把它赋值给***局部变量索引n位置***。
- 指令`xstore`由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。

说明:

***一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。***但是，为了尽可能压缩指令大小，使用专门的`istore_1`指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有`istore_0`、`istore_2`、 `istore_3`， 它们分别表示从操作数栈项弹出一个元素，存放在局部变量表第0、2、3个位置。

由于局部变量表前几个位置总是非常常用，***因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。***如果局部变量表很大，需要存储的槽位大于3，那么可以使用`istore`指令， 外加一个参数，用来表示需要存放的槽位位置。





# 算数指令

1. 作用

   算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。

2. 分类
   大体上算术指令可以分为两种:***对整型数据进行运算***的指令与***对浮点类型数据进行运算***的指令。

3. byte、 short、 char 和boolean类型说明

   在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、 char 和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、 short 和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。

![image-20201106115610055](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201106115610055.png)

4. 运算时的溢出

   数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虛拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现***除数为0时会导致虚拟机抛出异常ArithmeticException***。

5. 运算模式

   - 向最接近数舍入模式: JVM要求 在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值样接近，将优先选择最低有效位为零的
   - 向零舍入模式:将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；

6. NaN值使用

   当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN



## 所有算数指令

所有的算数指令包括：

![image-20201106122931095](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201106122931095.png)



## 比较指令说明







# 类型转换指令

## 宽化类型转换

## 窄化类型转换