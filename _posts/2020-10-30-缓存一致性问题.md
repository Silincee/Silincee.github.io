---
layout: post
title:  "缓存一致性问题"
date:   2020-10-30 12:03:02 +0800--
categories: [Java, 数据库]
tags: [Java, Redis]  
---



先做一个说明，从理论上来说，给缓存设置过期时间，是保**最终一致性**的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。在这里，我们讨论三种更新策略：

- 先更新数据库，再更新缓存；
- 先删除缓存，再更新数据库；
- 先更新数据库，再删除缓存；



# 先更新数据库，再更新缓存🙅

## 为什么会出现脏数据

先写db再更新缓存，也成为双写模式。这套方案，大家是普遍反对的，为什么呢？有如下两点原因：

### 线程安全角度

（1）请求A进行写操作更新了数据库

（2）请求B更新数据库；然后更新了缓存

（3）请求A更新了缓存；

![image-20210923103158842](/assets/imgs/image-20210923103158842.png)

### 业务场景角度

1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。

2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。



# 先删缓存，再更新数据库🙅

## 为什么会出现脏数据

该方案会导致不一致的原因是：同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:

（1）请求A进行写操作，删除缓存；

（2）请求B查询发现缓存不存在；请求B去数据库查询得到旧值；请求B将旧值写入缓存；

（3）请求A将新值写入数据库；

## 延时双删策略

那么，如何解决呢？**采用延时双删策略**！伪代码如下：

（1）先删除缓存；

（2）再写数据库（这两步和原来一样）；

（3）休眠1秒，再次删除缓存；

这么做，可以将1秒内所造成的缓存脏数据，再次删除！

![image-20210923132128668](/assets/imgs/image-20210923132128668.png)

> 这个1秒怎么确定的，具体该休眠多久呢？

针对上面的情形，应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

> 如果你用了MySQL的读写分离架构怎么办？

在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。

（1）请求A进行写操作，删除缓存；请求A将数据写入数据库了；

（2）请求B查询缓存发现，缓存没有值；请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值；请求B将旧值写入缓存；

（3）数据库完成主从同步，从库变为新值；

上述情形，就是数据不一致的原因。还是使用双删延时策略，只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。或者如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。

![image-20210923132746288](/assets/imgs/image-20210923132746288.png)

> 采用这种同步淘汰策略，吞吐量降低怎么办？

将第二次删除做成异步的方式。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。

> 第二次删除，如果删除失败怎么办？

这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：

（1）请求A进行写操作，删除缓存；

（2）请求B查询发现缓存不存在；请求B去数据库查询得到旧值；请求B将旧值写入缓存；

（3）请求A将新值写入数据库；

（4）请求A试图去删除请求B写入对缓存值，结果失败了；ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。

主要思路：利用消息队列进行删除的补偿



# 先更新数据库，再删缓存

## 为什么会出现脏数据

假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会产生脏数据：

（1）缓存刚好失效；请求A查询数据库，得一个旧值；

（2）请求B将新值写入数据库；请求B删除缓存；

（3）请求A将查到的旧值写入缓存；

发生上述情况有一个先天性条件，就是6.1中写数据库操作比读数据库操作耗时更短。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少，这一情形很难出现。

> 如何解决上述并发问题？

首先，给缓存设失效时间是一种方案。**其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。**

> 还有其他造成不一致的原因么？

有的，这也是缓存更新策略2（先删除缓存，再更新数据库）和缓存更新策略3（先更新数据库，再删除缓存）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略2（先删除缓存，再更新数据库）里留下的最后一个疑问。

## 解决方案-订阅binlog

提供一个保障的重试机制即可，这里给出两套方案。

> 方案一

（1）更新数据库数据；

（2）缓存因为种种问题删除失败；

（3）将需要删除的key发送至消息队列；

（4）自己消费消息，获得需要删除的key；

（5）继续重试删除操作，直到成功；

然而，该方案有一个缺点，对业务线代码造成大量的侵入。

于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

> 方案二

（1）更新数据库数据；

（2）数据库会将操作信息写入binlog日志当中；

（3）订阅程序提取出所需要的数据以及key；

（4）另起一段非业务代码，获得该信息；

（5）尝试删除缓存操作，发现删除失败；

（6）将这些信息发送至消息队列；

（7）重新从消息队列中获得该数据，重试操作；

备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。另外，重试机制采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。

其它方案：分布式读写锁，开销有点大。