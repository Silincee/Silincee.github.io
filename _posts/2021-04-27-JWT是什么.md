---
layout: post
title:  "JWT是什么"
date:   2021-04-27 19:42:06 +0800--
categories: [其他]
tags: [登陆验证, ]  
---

# 普通的用户认证流程

无状态协议(Stateless Protocol) 就是指**浏览器对于事务的处理没有记忆能力**。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。

那么无状态协议HTTP要如何保存用户状态呢？

**session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。**

**在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。**

一般流程是下面这样：

1. 用户向服务器发送用户名和密码。
2. 服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。
3. 服务器向用户返回一个 Session ID，写入用户的 Cookie。
4. 用户随后的每一次请求，都会通过 Cookie，将 Session ID 传回服务器。
5. 服务器收到 Session ID，找到前期保存的数据，由此得知用户的身份。

# JWT 的原理

JWT（ JSON Web Token ） 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。

```javascript
{
"姓名": "张三",
"角色": "管理员",
"到期时间": "2018年7月1日0点0分"
}
```

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。**服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名**。

**服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。**



# JWT的数据结构

实际的 JWT 大概就像下面这样。

![img](/Users/silince/Develop/博客/blog_to_git/assets/imgs/bg2018072304.jpg)

它是一个很长的字符串，中间用点（`.`）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。

JWT 的三个部分依次如下。

- Header（头部）
- Payload（负载）
- Signature（签名）

写成一行，就是下面的样子。

```java
Header.Payload.Signature
```

## Header（头部）

Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。

```javascript
{
  "alg": "HS256",
  "typ": "JWT"
}
```

上面代码中，`alg`属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；`typ`属性表示这个令牌（token）的类型（type），JWT 令牌统一写为`JWT`。

最后，将上面的 JSON 对象**使用 Base64URL 算法进行编码转成字符串。**

- Base64URL 算法：JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?**token=xxx**）。Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。



## Payload（负载）

Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段以供选用：

- iss (issuer)：签发人
- exp (expiration time)：过期时间
- sub (subject)：主题
- aud (audience)：受众
- nbf (Not Before)：生效时间
- iat (Issued At)：签发时间
- jti (JWT ID)：编号

除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。

```javascript
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。

**这个 JSON 对象也要使用 Base64URL 算法进行编码转成字符串。**



## Signature（签名）

Signature 部分是对前两部分的签名，防止数据篡改。

首先，**需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。**然后，使用 Header 里面指定的签名算法（默认是 HMAC-SHA256），按照下面的公式产生签名。

```java
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

**⭐️ 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（`.`）分隔，就可以返回给用户。**

客户端收到这个 Token 以后把它存储下来，之后向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。验证的过程就是：

- 根据传过来的token再生成一下第三部分Signature，然后两个比对一下，一致就验证通过。





# JWT 的使用方式

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，**所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。**

```javas
Authorization: Bearer <token>
```

另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。



# JWT方案中token的安全问题

token被劫持

按照JWT的流程,jwt是存储在客户端的,服务器不需要存储jwt;客户端每次发送请求时携带token，然后到服务端验证token是否正确，是否过期，然后解码出携带的用户信息。

根据以上流程 ，如果token在传输过程被攻击者截取了,那么对方就可以伪造请求,利用窃取的Token模拟正常请求，实现用户的正常操作,而服务器端对此完全不知道，因为JWT机制是无状态的。 

我们要明白JWT解决的是认证与授权的问题,上述劫持或者类似的中间人攻击是JWT不可避免的,也是其他认证与授权方式不可避免的,想避免可以使用HTTPS。



# JWT 的优缺点

优点：

- JWT 把用户状态存储在客户，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。另外jwt的负载中也可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数。
- 可扩展性好 ：应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要。JWT 支持跨域认证，Cookies 只能用在单个节点的域或者它的子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，可以把JWT放在 HTTP 请求头的`Authorization`字段里面，并通过`多个节点`进行用户认证，也就是我们常说的跨域认证。

缺点：

- **无法废弃：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。**
  - 比如你在payload中存储了一些信息，当信息需要更新时，则重新签发一个JWT，但是由于旧的JWT还没过期，拿着这个旧的JWT依旧可以登录，那登录后服务端从JWT中拿到的信息就是过时的。
  - 怎么处理：设置一个黑名单，一旦签发了新的jwt，那么旧的就加入黑名单（比如存到redis里面），避免被再次使用。不过这样的话和session没什么区别。

- 安全性：由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。



# 适合使用JWT的场景

有效期短，只希望被使用一次的场景。

比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的。这种场景就适合使用jwt。

而由于jwt具有一次性的特性。单点登录和会话管理非常不适合用jwt，如果在服务端部署额外的逻辑存储jwt的状态，那还不如使用session。基于session有很多成熟的框架可以开箱即用，但是用jwt还要自己实现逻辑。