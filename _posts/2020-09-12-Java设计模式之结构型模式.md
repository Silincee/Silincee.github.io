---
layout: post
title:  "Java设计模式之结构型模式"
date:   2020-09-13 09:58:06 +0800--
categories: [Java, 其他]
tags: [设计模式, ]  

---

# 适配器模式

基本介绍：

- 适配器模式(AdapterPattern)将某个类的接口转换成客户端期望的另一个接口表示，***主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作***。其别名为包装器(Wrapper)。
- 适配器模式属于结构型模式
- 主要分为三类:类适配器模式、对象适配器模式、接口适配器模式

工作原理：

- ***适配器模式:将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容***
- 从用户的角度看不到被适配者，是解耦的
- 用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
- 用户收到反馈结果，感觉只是和目标接口交互，如图

![image-20200914213109728](/assets/imgs/image-20200914213109728.png)

## [类适配器模式](https://github.com/Silincee/Design-pattern/tree/master/src/main/java/com/atguigu/adapter/classadapter)

**类适配器模式介绍**：Adapter 类，通过继承 src 类，实现 dst 类接口，完成 src->dst 的适配。

**类适配器模式应用实例**：

以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电

![image-20200914222241945](/assets/imgs/image-20200914222241945.png)

**类适配器模式注意事项和细节**：

- ***Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点***, 因为这要求 dst 必须是接口，有一定局 限性;
- ***src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。***
- 优点：由于其继承了src类，所以它可以根据需求重写src类的方法，使得***Adapter的灵活性增强***了。

## [对象适配器模式](https://github.com/Silincee/Design-pattern/tree/master/src/main/java/com/atguigu/adapter/objectadapter)

- 本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决

  兼容性的问题。 即:持有 src 类，实现 dst 类接口，完成 src->dst 的适配

- 根据***“合成复用原则”***，在系统中尽量使用***关联关系(聚合)***来替代继承关系。

- 对象适配器模式是适配器模式常用的一种

应用实例说明:

以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即目标)是 5V 直流电，使用对象适配器模式完成。

![image-20200915183214205](/assets/imgs/image-20200915183214205.png)

对象适配器模式注意事项和细节:

- ***对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst 必须是接口。***
- 使用成本更低，更灵活。

## [接口适配器模式](https://github.com/Silincee/Design-pattern/tree/master/src/main/java/com/atguigu/adapter/interfaceadapter)

- 一些书籍称为:适配器模式(DefaultAdapterPattern)或缺省适配器模式。
- ***核心思路:当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求***
- 适用于***一个接口不想使用其所有的方法***的情况。

 ![image-20200915190559858](/assets/imgs/image-20200915190559858.png)

## 适配器模式在 SpringMVC 框架应用的源码剖析

1. SpringMvc中的HandlerAdapter，就使用了适配器模式
2. 使用HandlerAdapter的原因分析:
   - 可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller， 就得修改原来的代码，这样违背了 OCP 原则。
3. 代码分析+Debug源码

![image-20200915215351853](/assets/imgs/image-20200915215351853.png)

![image-20200915215408122](/assets/imgs/image-20200915215408122.png)

## 适配器模式的注意事项和细节

1. 三种命名方式，是根据***src是以怎样的形式给到Adapter(在Adapter里的形式)来命名的***。

2. 类适配器:以类给到，在Adapter里，***就是将src当做类，继承***

   对象适配器:以对象给到，在 Adapter 里，***将 src 作为一个对象，持有***

   接口适配器:以接口给到，在 Adapter 里，***将 src 作为一个接口，实现***

3. Adapter 模式最大的***作用还是将原本不兼容的接口融合在一起工作。***

4. 实际开发中，实现起来不拘泥于我们讲解的三种经典形式



# [桥接模式](https://github.com/Silincee/Design-pattern/tree/master/src/main/java/com/atguigu/bridge)

## 手机操作问题

现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，如图:

![image-20200915221218357](/assets/imgs/image-20200915221218357.png)

传统方案解决手机操作问题:

![image-20200915221240739](/assets/imgs/image-20200915221240739.png)

传统方案解决手机操作问题分析:

- ***扩展性问题(类爆炸)***，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加 一个手机品牌，也要在各个手机样式类下增加。
- 违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.
- ***解决方案-使用桥接模式***        

## 桥接模式(Bridge)-基本介绍

- ***桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。***
- Bridge 模式基于类的最小设计原则（类尽量少），通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展
- 是一种结构型设计模式

桥接模式(Bridge)-原理类图:

![image-20200915221430000](/assets/imgs/image-20200915221430000.png)

说明：

- Client 类:桥接模式的调用者
- 抽象类(Abstraction) :维护了 Implementor / 即它的实现类 ConcreteImplementorA.., 二者是聚合关系, Abstraction充当桥接类
- RefinedAbstraction : 是 Abstraction 抽象类的子类
- Implementor : 行为实现类的接口
- ConcreteImplementorA /B :行为的具体实现类
- 从UML图:这里的抽象类和接口是聚合的关系，其实调用和被调用关系

## 桥接模式解决手机操作问题

![image-20200915221624326](/assets/imgs/image-20200915221624326.png)

## 桥接模式在 JDBC 的源码剖析

Jdbc 的 **Driver** 接口，如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver，Oracle 的

Driver，这些就可以当做实现接口类

![image-20200915221707181](/assets/imgs/image-20200915221707181.png)

## 桥接模式的注意事项和细节

1. 实现了***抽象和实现部分的分离***，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于 系统进行分层设计，从而产生更好的结构化系统。
2. ***对于系统的高层部分，只需要知道抽象部分和实现部分的接口***就可以了，其它的部分由具体业务来完成。
3. ***桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。***
4. 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5. 桥接模式要求***正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性***，即需要有这样的应用场景。
6. 对于那些***不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.***
   - JDBC驱动程序
   - 银行转账系统
     - 转账分类: 网上转账，柜台转账，AMT 转账
     - 转账用户类型:普通用户，银卡用户，金卡用户..
   - 消息管理
     - 消息类型:即时消息，延时消息
     - 消息分类:手机短信，邮件消息，QQ 消息...

# [装饰者设计模式](https://github.com/Silincee/Design-pattern/tree/master/src/main/java/com/atguigu/decorator)

## 星巴克咖啡订单项目(咖啡馆)

- 咖啡种类/单品咖啡:Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)
- 调料:Milk、Soy(豆浆)、Chocolate
- 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
- 使用OO的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。

### 方案一

![image-20200916203003942](/assets/imgs/image-20200916203003942.png)

方案 1问题分析：

1. Drink 是一个抽象类，表示饮料
2. des 就是对咖啡的描述, 比如咖啡的名字
3. cost() 方法就是计算费用，Drink 类中做成一个抽象方法.
4. Decaf 就是单品咖啡， 继承 Drink, 并实现 cost
5. Espress && Milk 就是单品咖啡+调料， 这个组合很多
6. ***问题:这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸***

### 方案二

前面分析到方案 1 因为咖啡单品+调料组合会造成类的倍增，因此可以做改进，将调料内置到 Drink 类，这样就不会造成类数量过多。从而提高项目的维护性(如图)：

说明: milk,soy,chocolate 可以设计为 Boolean,表示是否要添加相应的调料

![image-20200916203207006](/assets/imgs/image-20200916203207006.png)

方案 2问题分析：

1. 方案2可以控制类的数量，不至于造成很多的类
2. 在增加或者删除调料种类时，代码的维护量很大
3. 考虑到用户可以添加多份调料时，可以将hasMilk返回一个对应int
4. ***考虑使用装饰者模式***

## 装饰者模式定义

- 装饰者模式:***动态的将新功能附加到对象上***。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了 开闭原则**(ocp**)
- 这里提到的***动态的将新功能附加到对象和ocp原则***，在后面的应用实例上会以代码的形式体现，请同学们注意 体会。

## 装饰者模式原理

- 装饰者模式就像打包一个快递。主体:比如:陶瓷、衣服 (Component) // 被装饰者；包装:比如:报纸填充、塑料泡沫、纸板、木板(Decorator)
-  Component主体:比如类似前面的Drink
- ConcreteComponent和Decorator
  - ConcreteComponent:具体的主体；比如前面的各个单品咖啡
  -  Decorator：装饰者，比如各调料.

在如图的 Component 与 ConcreteComponent 之间，如果 ConcreteComponent 类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。

![image-20200916210728884](/assets/imgs/image-20200916210728884.png)

## 装饰者模式解决星巴克咖啡订单

![image-20200916210902889](/assets/imgs/image-20200916210902889.png)

装饰者模式下的订单:2 份巧克力+一份牛奶的 LongBlack

![image-20200916210924124](/assets/imgs/image-20200916210924124.png)

## 装饰者模式在 JDK 应用的源码分析

Java 的 IO 结构，FilterInputStream 就是一个装饰者

```xml
//说明
//1. InputStream 是抽象类, 类似我们前面讲的 Drink
//2. FileInputStream 是 InputStream 子类，类似我们前面的 DeCaf, LongBlack
//3. FilterInputStream 是 InputStream 子类:类似我们前面 的 Decorator 修饰者
//4. DataInputStream 是 FilterInputStream 子类，具体的修饰者，类似前面的 Milk, Soy 等 
//5. FilterInputStream 类 有 protected volatile InputStream in; 即含被装饰者
```

![image-20200916215152617](/assets/imgs/image-20200916215152617.png)

# 组合模式

编写程序展示一个学校院系结构:需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。如图:

![image-20200916221615899](/assets/imgs/image-20200916221615899.png)

传统方案解决学校院系展示存在的问题分析:

1. ***将学院看做是学校的子类，系是学院的子类***，这样实际上是站在组织大小来进行分层次的
2. 实际上我们的要求是:在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，不能很好实现管理的操作，***比如对学院、系的添加、删除和遍历等。***
3. 解决方案:把学校、院、系都看做是组织结构，他们之间没有继承的关系，而是一个树形结构，可以更好的实现管理操作。 => ***组合模式***

## 组合模式基本介绍

- 组合模式(CompositePattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成***树状结构***以 表示“***整体-部分***”的层次关系。
- 组合模式***依据树形结构来组合对象***，用来表示部分以及整体层次。
- 这种类型的设计模式属于结构型模式。
- 组合模式使得***用户对单个对象和组合对象的访问具有一致性***，即:组合能让客户以一致的方式处理个别对象以及组合对象

![image-20200916223100579](/assets/imgs/image-20200916223100579.png)

- **Component** :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口
- **Leaf :** 在组合中表示叶子节点，叶子节点没有子节点
- **Composite** :非叶子节点， 用于存储子部件， 在 Component接口中实现 子部件的相关操作，比如增加(add)。

## 组合模式解决学校院系展示的应用实例

编写程序展示一个学校院系结构:需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。

![image-20200916223256705](/assets/imgs/image-20200916223256705.png)

## 组合模式在 JDK 集合的源码分析

Java 的集合类-**HashMap** 就使用了组合模式

![image-20200916223349346](/assets/imgs/image-20200916223349346.png)

## 组合模式的注意事项和细节

1. 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
2. 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
3. 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
4. 需要***遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式.***
5. 要求较高的抽象性，如果***节点和叶子有很多差异性***的话，比如很多方法和属性都不一样，***不适合使用组合模式***



# 外观模式

# 享元模式

# 代理模式