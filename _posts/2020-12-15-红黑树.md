---
layout: post
title:  "红黑树"
date:   2020-07-15 12:10:06 +0800--
categories: [数据结构]
tags: [树, 数据结构, 红黑树 ]  

---

# 二叉排序树/二叉查找树/二叉搜索树

## 二叉排序树（BST，Binary Sort Tree）的性质

- 有非叶子结点至多拥有两个儿子（Left和Right）
- 所有结点存储一个关键字；

- 对于二叉树中的任意节点，如果它有左子树或右子树，则***该节点的数据成员大于左子树所有节点的数据成员，且小于右子树所有节点的数据成员***。
- 排序二叉树的中序遍历结果是从小到大排列的。

![Image](/assets/imgs/640-20210117223603082.png)

## 二叉排序树的优势

- **这种方式正是二分查找的思想，查找所需的最大次数等同于二叉查找树的高度。**
- **在插入节点的时候也是利用类似的方法，通过一层一层比较大小，找到新节点适合插入的位置。**

1.查看根节点**9**：

![Image](/assets/imgs/640-20210117223729930.png)





2.由于**10 > 9**，因此查看右孩子**13**：

![Image](/assets/imgs/640-20210117223729910.png)





3.由于**10 < 13**，因此查看左孩子**11**：

![Image](/assets/imgs/640-20210117223729937.png)





4.由于**10 < 11**，因此查看左孩子**10**，发现10正是要查找的节点：

![Image](/assets/imgs/640-20210117223729908.png)

## 二叉排序树的缺陷

- 这样的形态虽然也符合二叉查找树的特性，但是查找的性能大打折扣，几乎变成了线性。
- 如何解决二叉查找树多次插入新节点而导致的不平衡呢？我们的主角**【红黑树】**应运而生了。

缺陷体现在插入新节点的时候。让我们来看看下面这种情形:

1.假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12：

![Image](/assets/imgs/640-20210117224027338.png)



2.接下来我们依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性，结果会变成什么样呢？

![Image](/assets/imgs/640-20210117224027202.png)



# 红黑树

> 关于红黑树自平衡的调整，插入和删除节点的时候都涉及到很多种Case，由于篇幅原因无法展开来一一列举，有兴趣的朋友可以参考维基百科，里面讲的非常清晰
>
> 红黑树调整过程的示例是一种比较复杂的情形，没太看明白的小伙伴也不必钻牛角尖，关键要懂得红黑树自平衡调整的主体思想

## 红黑树的性质

红黑树（Red Black Tree）是一种自平衡的二叉查找树。除了符合二叉查找树的基本特性外，它还具有下列的附加特性:

- 节点是红色或黑色。
- 根节点是黑色。
- 每个叶子节点都是黑色的空节点（NIL节点）
- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点）
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

下图中这棵树，就是一颗典型的红黑树：

![Image](/assets/imgs/640.jpeg)

<u>**正是因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。**</u>

**<u>当插入或删除节点的时候，红黑树的规则有可能被打破。这时候就需要做出一些调整，来继续维持我们的规则。</u>**

****

> 什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的栗子：

1.向原红黑树插入值为**14**的新节点：由于父节点15是黑色节点，因此这种情况并不会破坏红黑树的规则，无需做任何调整。

![Image](/assets/imgs/640-20210117224655675.jpeg)



2.向原红黑树插入值为**21**的新节点：由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。

![Image](/assets/imgs/640-20210117224655512.jpeg)

## 红黑树的调整方法

那么，我们需要做出怎样的调整，才能保证一颗红黑树始终是红黑树呢？

调整有两种方法:【变色】和【旋转】。而旋转又分成两种形式:【左旋转】和【右旋转】。

### 变色

为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。

下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：

![Image](/assets/imgs/640-20210117225233681.png)

但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：

![Image](/assets/imgs/640-20210117225233628.png)

此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：

![Image](/assets/imgs/640-20210117225233635.png)

### 左旋转

**逆时针**旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：

![Image](/assets/imgs/640-20210117225233657.png)

图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。

### 右旋转

**顺时针**旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：

![Image](/assets/imgs/640-20210117225233581.png)

图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。

## 调整方法使用场景

究竟什么时候用到变色，什么时候用到旋转呢？

红黑树的插入和删除包含很多种情况，每一种情况都有不同的处理方式。在这里我们举一个典型例子，大家体会一下。

我们以刚才插入节点21的情况为例：



![Image](/assets/imgs/640-20210117225615274.jpeg)

首先，我们需要做的是**变色**，把节点25及其下方的节点变色：

![Image](/assets/imgs/640-20210117225615241.png)

此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。

变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行**左旋转**：

![Image](/assets/imgs/640-20210117225615270.png)

![Image](/assets/imgs/640-20210117225615242.png)

![Image](/assets/imgs/640-20210117225615264.jpeg)

由于根节点必须是黑色节点，所以需要**变色**，变色结果如下：



![Image](/assets/imgs/640-20210117225615250.jpeg)

这样就结束了吗？并没有。因为其中两条路径(17 -> 8 -> 6 -> NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。

这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行**右旋转**：

![Image](/assets/imgs/640-20210117225615384.png)

![Image](/assets/imgs/640-20210117225615260.jpeg)

![Image](/assets/imgs/640-20210117225615268.png)

最后根据规则来进行**变色**：

![Image](/assets/imgs/640-20210117225615278.jpeg)

如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤：

**变色 -> 左旋转 -> 变色 -> 右旋转 -> 变色**



## 红黑树的应用

红黑树的应用有很多，其中 JDK 的集合类 TreeMap 和 TreeSet底层就是红黑树实现的。在Java8中，连HashMap 也用到了红黑树。