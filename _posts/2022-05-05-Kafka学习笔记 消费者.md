---
layout: post
title:  "Kafka学习笔记 消费者"
date:   2022-05-05 12:19:06 +0800--
categories: [Kafka]
tags: [Kafka, ]  
---

# Kafka 消费者

## 消费方式

pull(拉)模式: 

- consumer采用从broker中主动拉取数据。Kafka采用这种方式。
- pull模式不足之处是，如果Kafka没有数据，消费者可能会陷入循环中，一直返回空数据。

push(推)模式:

- Kafka没有采用这种方式，因为由broker 决定消息发送速率，很难适应所有消费者的消费速率。例如推送的速度是50m/s， Consumer1、Consumer2就来不及处理消息。

![image-20220506165214629](/assets/imgs/image-20220506165214629.png)



## 消费者工作流程

1）消费者总体工作流程



![image-20220506165330797](/assets/imgs/image-20220506165330797.png)

2）消费者组

Consumer Group(CG)：消费者组，由多个consumer组成。形成一个消费者组的条件，是所有消费者的groupid相同。

- 消费者组内每个消费者负责消费不同分区的数据，**一个分区只能由一个组内的消费者消费。**
- **消费者组之间互不影响。**所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。

![image-20220506165624240](/assets/imgs/image-20220506165624240.png)

- 如果向消费组中添加更多的消费者，超过 主题分区数量，则有一部分消费者就会闲 置，不会接收任何消息。

![image-20220506165729004](/assets/imgs/image-20220506165729004.png)

3）消费者组初始化流程

coordinator：辅助实现消费者组的初始化和分区的分配。

- coordinator节点选择=groupid的nashcode值%50(\_consumer_offsets的分区数量)_
- 例如：groupid的hashcodef值=1，1%50=1，那么\_consumer_offsets主题的1号分区，在哪个broker上，**就选择这个节点的coordinator 作为这个消费者组的老大。消费者组下的所有的消费者提交offset的时候就往这个分区去提交offset。**

![image-20220506165927636](/assets/imgs/image-20220506165927636.png)

⚠️触发再平衡的两个条件：

- 每个消费者都会和coordinator保持心跳(默认3s)，一旦超时 (session.timeout.ms=45s)，该消费者会被移除，并触发再平衡;
- 或者消费者处理消息的时间过长(超过max.poll.interval.ms5分钟)，也会触发再平衡



4）消费流程

1. 创建COnsumerNetworkClient，接收消费者的消费请求sendFetches
2. ConsumerNetworkClient通过send方法拉去broker中的消息，broker也有相应onSuccess回调方法
3. 把拉去的消息放入completedFetches队列，消费者会按批次拉取数据
4. 反序列化/拦截器/处理数据

![image-20220506180242291](/assets/imgs/image-20220506180242291.png)



## 消费者API

### 独立消费者(订阅主题)

需求：创建一个独立消费者，消费 first 主题中数据。

![image-20220506183248510](/assets/imgs/image-20220506183248510.png)

代码：⚠️在消费者 API 代码中必须配置消费者组 id。命令行启动消费者不填写消费者组 id 会被自动填写随机的消费者组 id。

```java
/**
 * 独立消费者案例(订阅主题)
 *
 * @author zhongye
 * @since 2022.05.06
 */
public class CustomConsumer {
  public static void main(String[] args) {
    //0 配置
    Properties properties = new Properties();

    //连接bootstrap.servers
    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9092");

    // 反序列化
    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
    // 指定消费者组id
    properties.put(ConsumerConfig.GROUP_ID_CONFIG,"test");

    // 1 创建一个消费者 "","hello"
    KafkaConsumer<String, String> kafkaConsumer = new KafkaConsumer<>(properties);

    // 2 订阅主题 first
    ArrayList<String> topics = new ArrayList<>();
    topics.add("first");
    kafkaConsumer.subscribe(topics);

    // 3 消费数据
    while (true){
      ConsumerRecords<String, String> consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(1));
      for (ConsumerRecord<String, String> consumerRecord : consumerRecords) {
        System.out.println(consumerRecord);
      }
    }

  }
}
```

执行结果：消息由[普通异步发送](http://www.silince.cn/2022/04/22/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%94%9F%E4%BA%A7%E8%80%85/#%E6%99%AE%E9%80%9A%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81)生产

```shell
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 22, CreateTime = 1651833006318, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince0)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 23, CreateTime = 1651833006336, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince1)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 24, CreateTime = 1651833006336, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince2)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 25, CreateTime = 1651833006336, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince3)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 26, CreateTime = 1651833006336, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince4)
```



### 独立消费者(订阅分区)

需求：创建一个独立消费者，消费 first 主题下 0 号分区的数据(指定分区消费)。

![image-20220506183331738](/assets/imgs/image-20220506183331738.png)

代码：

```java
/**
 * 消费 first 主题下 0 号分区的数据(指定分区消费)。
 *
 * @author zhongye
 * @since 2022.05.06
 */
public class CustomConsumerPartition {
  public static void main(String[] args) {
    //0 配置
    Properties properties = new Properties();

    //连接bootstrap.servers
    properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,"localhost:9092");

    // 反序列化
    properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
    properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());
    // 指定消费者组id
    properties.put(ConsumerConfig.GROUP_ID_CONFIG,"test");

    // 1 创建一个消费者 "","hello"
    KafkaConsumer<String, String> kafkaConsumer = new KafkaConsumer<>(properties);

    // 2 订阅主题对应的分区
    ArrayList<TopicPartition> topics = new ArrayList<>();
    topics.add(new TopicPartition("first",0));
    kafkaConsumer.assign(topics);

    // 3 消费数据
    while (true){
      ConsumerRecords<String, String> consumerRecords = kafkaConsumer.poll(Duration.ofSeconds(1));
      for (ConsumerRecord<String, String> consumerRecord : consumerRecords) {
        System.out.println(consumerRecord);
      }
    }

  }
}
```



执行结果：如指定的分区为1，那就不会消费消息(消息由[普通异步发送](http://www.silince.cn/2022/04/22/Kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%94%9F%E4%BA%A7%E8%80%85/#%E6%99%AE%E9%80%9A%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81)生产)。

```java
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 32, CreateTime = 1651840032039, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince0)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 33, CreateTime = 1651840032051, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince1)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 34, CreateTime = 1651840032052, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince2)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 35, CreateTime = 1651840032052, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince3)
ConsumerRecord(topic = first, partition = 0, leaderEpoch = 0, offset = 36, CreateTime = 1651840032052, serialized key size = -1, serialized value size = 8, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = silince4)
```



### 消费者组

需求:测试同一个主题的分区数据，只能由一个消费者组中的一个消费。

![image-20220506203115326](/assets/imgs/image-20220506203115326.png)

代码：复制两份独立消费者(订阅主题)即可，因为groupid相同，所以自动会组成一个消费者组







## 分区的分配以及再平衡

1. 一个consumer group中有多个consumer组成，一个 topic有多个partition组成，现在的问题是，到底由哪个consumer来消费哪个 partition的数据。
2. Kafka有四种主流的分区分配策略: ==Range、RoundRobin、Sticky、CooperativeSticky。==
3. 可以通过配置参数partition.assignment.strategy，修改分区的分配策略。默认策略是==Range+ CooperativeSticky==。Kafka可以同时使用。

![image-20220506205145363](/assets/imgs/image-20220506205145363.png)

### **Range** 以及再平衡

Range 是对每个 topic 而言的。首先对同一个 topic 里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。

- 如现在有 7 个分区，3 个消费者，排序后的分区将会是0,1,2,3,4,5,6;消费者排序完之后将会是C0,C1,C2。通过 partitions数/consumer数 来决定每个消费者应该 消费几个分区。如果除不尽，那么前面几个消费者将会多消费 1 个分区。
- 例如，7/3=2余1，除不尽，那么消费者C0便会多消费1个分区。8/3=2余2，除不尽，那么C0和C1分别多消费一个。

⚠️：如果只是针对1个topic而言，C0消费者多消费1 个分区影响不是很大。但是如果有N多个topc，那么针对每 个topic，消费者C0都将多消费1个分区，topic越多，C0消费的分区会比其他消费者明显多消费N个分区。==容易产生数据倾斜==

![image-20220506231758996](/assets/imgs/image-20220506231758996.png)

### **RoundRobin** 以及再平衡



### **Sticky** 以及再平衡





## offset位移



## 消费者事务



## 数据积压





