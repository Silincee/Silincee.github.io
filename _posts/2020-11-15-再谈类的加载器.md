---
layout: post
title:  "再谈类的加载器"
date:   2020-11-15 19:21:16 +0800--
categories: [JVM,]
tags: [Java, JVM, 类加载器]  

---

# 概述

类加载器是JVM执行类加载机制的前提。

***ClassLoader的作用:***

***ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的`java.lang. Class`对象实例。***然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由`Execution Engine`决定。

![image-20201115193256464](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201115193256464.png)

类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在0SGi、字节码加解密领域大放异彩。***这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。***



## 大厂面试题

蚂蚁金服:

- 深入分析ClassLoader，双亲委派机制
- 类加载器的双亲委派模型是什么？ 
- 一面:双亲委派机制及使用原因

百度:

- 都有哪些类加载器，这些类加载器都加载哪些文件？
- 手写一个类加载器Demo
- `Class的forName("java.lang.String")`和`Class的getClassLoader()``loadClass("java.lang.String")`有什么区别？

腾讯:

- 什么是双亲委派模型？
- 类加载器有哪些？

小米:

- 双亲委派模型介绍一下

滴滴:

- 简单说说你了解的类加载器
- 一面:讲一下双亲委派模型，以及其优点

字节跳动:

- 什么是类加载器，类加载器有哪些？

京东:

- 类加载器的双亲委派模型是什么？双亲委派机制可以打破吗？为什么



## 类加载的分类

***类的加载分类:显式加载 vs 隐式加载***

class文件的显式加载与隐式加载的方式是***指JVM加载class文件到内存的方式***：

- 显式加载指的 是在代码中通过调用ClassLoader加载class对象，如直接使用`Class.forName (name)`或
  `this.getClass().getClassLoader().loadClass()`加载class对象。
- 隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。

在日常开发以上两种方式一般会混合使用。

```java
public class UserTest {
    public static void main(String[] args) {
        User user = new User(); //隐式加载

        try {
            Class clazz = Class.forName("com.atguigu.java.User"); //显式加载
            ClassLoader.getSystemClassLoader().loadClass("com.atguigu.java.User");//显式加载
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

    }
}
```





## 类加载器的必要性

一.般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说:

- 避免在开发中遇到`java.lang.ClassNotFoundException异常`或`java.lang.NoClassDefFoundError异常`时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题
- 需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。
- 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。



## 命名空间

1.何为类的唯一性？

对于任意一个类，***都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。***

每一个类加载器，都拥有一个独立的类名称空间:***比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。***否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，***只要加载他们的类加载器不同，那这两个类就必定不相等。***



2.命名空间

每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成

- 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

***⭐️ 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。***



## 类加载机制的基本特征

通常类加载机制有三个基本特征:

- ***双亲委派模型。 但不是所有类加载都遵守这个模型***，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的`ServiceProvider/ServiceLoader`机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、 JDBC、 文件系统、Cipher等很多方面，都是利用的这种机制，***这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。***
- ***可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。***不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。
- ***单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。***但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。



# 类加载器的分类

JVM支持两种类型的类加载器，分别为***引导类加载器（Bootstrap ClassLoader） 和自定义类加载器（User-Defined ClassLoader 包括扩展类和应用程序类加载器）。***

从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是***将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器***。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:

- 除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。
- 不同类加载器看似是继承（ Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用

![image-20201115221621066](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201115221621066.png)





## 引导类加载器

启动类加载器（ 引导类加载器，Bootstrap ClassLoader），使用 `-Xx: +TraceClassLoading`参数可查看加载过程。

- 这个类加载使用***C/C++语言实现的，嵌套在JVM内部***
- 它用来加载Java的核心库（`JAVA_HOME/jre/lib/rt.jar`或`sun.boot.class.path`路径下的内容），用于提供JVM自身需要的类
- 并不继承自`java. lang. ClassLoader`， 没有父加载器
- ***出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、 sun等开头的类***
- ***加载扩展类和应用程序类加载器，并指定为他们的父类加载器***



## 扩展类加载器

扩展类加载器（Extension ClassLoader）

- Java语言编写，由`sun. misc. Launcher$ExtClassLoader`实现。
- 继承于`ClassLoader`类
- 父类加载器为启动类加载器
- 从`java. ext .dirs`系统属性所指定的目录中加载类库，或从JDK的安装目录的`jre/lib/ext`子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

![image-20201115223622669](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201115223622669.png)



## 系统类加载器

应用程序类加载器（系统类加载器，AppClassLoader）

- java语言编写，由`sun. misc. Launcher$AppClassLoader`实现
- 继承于`ClassLoader`类
- 父类加载器为扩展类加载器
- 它负责加载环境变量`classpath`或系统属性`java. class.path`指定路径下的类库
- ***应用程序中的类加载器默认是系统类加载器。***
- ***它是用户自定义类加载器的默认父加载器***
- 通过`ClassLoader`的`getSystemClassLoader()`方法可以获取到该类加载器



## 用户自定义类加载器

用户自定义类加载器：

- 在Java的日常应用程序开发中， 类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。
- 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。
- ***通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。***例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。
- ***同时，自定义加载器能够实现应用隔离，***例如Tomcat， Spring等中 间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。
- 自定义类加载器通常需要继承于ClassLoader。



# 测试不同的类加载器

每个Class对象都会包含一个定义它的ClassLoader的一个引用。

获取ClassLoader的途径：

- 获取当前类的ClassLoader：`clazz.getClassLoader()`
- 获取当前线程上下文的ClassLoader：`Thread.currentThread.getContextClassLoader()`
- 获取系统的ClassLoader：`ClassLoader.getSystemClassLoader()`

说明:

站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。***由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。***

数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。***对于数组类的类加载器来说，是通过`Class.getClassLoader()`返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。***

```java
public class ClassLoaderTest1 {
    public static void main(String[] args) {
        //获取系统该类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
        //获取扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d
        //试图获取引导类加载器：失败
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);//null
      
        //###########################
        try {
            ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
            System.out.println(classLoader); //null
            //自定义的类默认使用系统类加载器
            ClassLoader classLoader1 = Class.forName("com.atguigu.java.ClassLoaderTest1").getClassLoader();
            System.out.println(classLoader1);
          
            //关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同
            String[] arrStr = new String[10];
            System.out.println(arrStr.getClass().getClassLoader());//null:表示使用的是引导类加载器

            ClassLoaderTest1[] arr1 = new ClassLoaderTest1[10];
            System.out.println(arr1.getClass().getClassLoader());//sun.misc.Launcher$AppClassLoader@18b4aac2

            int[] arr2 = new int[10];
            System.out.println(arr2.getClass().getClassLoader());//null:不需要类的加载器

            System.out.println(Thread.currentThread().getContextClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```





# ClassLoader源码解析

ClassLoader与现有类加载器的关系:

![image-20201116094658535](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201116094658535.png)

除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类`java.lang.ClassLoader`，所有用户自定义的类加载器都应该继承`ClassLoader`类。



## ClassLoader的主要方法

***抽象类ClassLoader的主要方法（ 内部没有抽象方法）:*** 

1.返回该类加载器的超类加载器

- `public final ClassLoader getParent()`

2.加载名称为name的类，返回结果为`java.lang.Class类`的实例。如果找不到类，则返回`ClassNotFoundException`异常。***该方法中的逻辑就是双亲委派模式的实现。***

- `public Class<?> loadClass（String name） throws ClassNotFoundException`

```java
// 测试代码： ClassLoader.getSystemClassLoader().loadClass("cn.silince.User")
// 涉及到以下方法的调用：
protected Class<?> loadClass(String name, boolean resolve)
  throws ClassNotFoundException // resolve:true-加载class的同时进行解析操作
{
  synchronized (getClassLoadingLock(name)) { // 同步操作，保证只能加载一次
    // 首先，在缓存中判断是否已经加载同名的类
    Class<?> c = findLoadedClass(name);
    if (c == null) { // 首次加载
      long t0 = System.nanoTime();
      try {
        if (parent != null) { // 获取当前类加载器的父类加载器
          c = parent.loadClass(name, false);//⚠️递归;如果存在父类加载器，则调用父类加载器进行类的加载
        } else { // 父类加载器是引导类加载器(null)
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // ClassNotFoundException thrown if class not found
        // from the non-null parent class loader
      }

      if (c == null) { // 当前的类加载器的父类加载器未加载此类 or 当前类的加载器未加载此类
        // 调用当前ClassLoader的findClass()方法
        long t1 = System.nanoTime();
        c = findClass(name); // 查找二进制名称为name的类，不存在返回null

        // this is the defining class loader; record the stats
        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
        sun.misc.PerfCounter.getFindClasses().increment();
      }
    }
    if (resolve) { // 是否进行解析操作
      resolveClass(c);
    }
    return c; // 父类加载器返回null(c)给系统类加载器
  }
}
```



3.查找二进制名称为name的类，返回结果为`java.lang.Class`类的实例。这***是个受保护的方法， JVM鼓励我们重 写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被`loadClass()`方法调用。***

- `protected Class<?> findClass（String name） throws ClassNotFoundException`
- 该方法在`java.net.URLClassLoader.java`中被重写
- 在JDK1.2之前，在自定义类加载时，总会去继承`ClassLoader`类并重写`loadClass`方法，从而实现自定义的类加载类。***但是在JDK1. 2之后已不再建议用户去覆盖`loadClass()`方法，而是建议把自定义的类加载逻辑写在`findClass()`方法中***，从前面的分析可知，`findClass()`方法是在`loadClass()`方法中被调用的，当
  `loadClass()`方法中父加载器加载失败后，则会调用自己的`findClass()`方法来完成类加载，这样就***可以保证自定义的类加载器也符合双亲委托模式。***
- 需要注意的是`ClassLoader`类中并没有实现`findClass()`方法的具体代码逻辑，取而代之的是抛出
  `ClassNotFoundException`异常，同时应该知道的是`findClass `方法通常是和`defineClass`方法一起使用的。***一般情况下，在自定义类加载器时，会直接覆盖`ClassLoader的findClass()`方法并编写加载规则，取得要加载类的字节码后转换成流， 然后调用`defineClass()`方法生成类的Class对象。***





4.***根据给定的字节数组b转换为Class的实例***，`off`和`len`参数表示实际Class信息在byte数组中的位置和长度，其中，byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。

- `protected final Class<?> defineClass（String name， byte[] b， int off， int len）`
- `defineClass()`方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。
- ***`defineClass()`方法通常与`findClass()`方法一起使用，一般情况下，在自定义类载器时，会直接覆盖***
  ***`ClassLoader`的`findClass()`方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用`defineClass()`方法生成类的Class对象***

简单距离：

```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
  // 获取类的class文件字节数组
  byte[] classData = getClassData(name);
  if (classData == null) {
    throw new ClassNotFoundException();
  } else {
    //直接生成class对象
    return defineClass(name, classData, 0, classData.length);
  }
}
```

5.链接指定的一个Java类。***使用该方法可以使用类的Class对象创建完成的同时也被解析。***前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。

- `protected final void resolveClass(Class<?> c)`

6.***查找名称为name的已经被加载过的类***，返回结果为`java.lang.Class`类的实例。这个方法是final方法，无法被修改。

- `protected final Class<?> findLoadedClass（String name）`

7.它也是一个ClassLoader的实例， ***这个字段所表示的ClassLoader也称为这个ClassLoader的双亲***。 在类加载的过程中J ClassLoader可能会将某些请求交予自己的双亲处理。

- `private final ClassLoader parent`



## SecureClassLoader与URLClassLoader

接着`SecureClassLoader`扩展了`ClassLoader`， 新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类`URLClassLoader`有所关联。

前面说过，`ClassLoader`是一 个抽象类， 很多方法是空的没有实现，比如`findClass()`、` findResource()`等。 而`URLClassLoader`这个实现类为这些方法提供了具体的实现。并新增了`URLClassPath`类协助取得Class字节码流等功能。***在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承`URLClassLoader`类，*** ***这样就可以避免自已去编写`findClass()`方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。***

![image-20201116130727468](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201116130727468.png)





## ExtClassLoader和AppClassLoader

了解完`URLClassLoader`后接着看看剩余的两个类加载器，即拓展类加载器`ExtClassLoader`和系统类加载器`AppClassLoader`，这两个类都继承自`URLClassLoader`，是`sun.misc.Launcher`的静态内部类。

`sun.misc.Launcher`主要被系统用于启动主应用程序，`ExtClassLoader` 和`AppClassLoader`都是由
`sun.misc.Launcher`创建的，其类主要类结构如下:

![image-20201116133614125](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201116133614125.png)



***我们发现`ExtClassLoader`并没有重写`loadClass()`方法，这足已说明其遵循双亲委派模式，而`AppClassLoader`重载了`loadClass()`方法，但最终调用的还是父类`loadClass()`方法，因此依然遵守双亲委派模式。***



## Class.forName()与ClassLoader.loadClass()

`Class. forName()`: 是一个静态方法，最常用的是`Class.forName(String className)`；根据传入的类的全限定名返回一个Class对象。***该方法在将Class文件加载到内存的同时，会执行类的初始化（主动使用）。***如:
`Class . forName("com. atguigu. java. HelloWorld")`；

`ClassLoader.loadClass()`: 这是一个实例方法，需要一个ClassLoader对象来调用该方法。***该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化(被动使用)。***该方法因为需要得到个ClassLoader 对象，所以可以根据需要指定使用哪个类加载器.如: `ClassLoader cl=......`；
`cl.loadClass("com.atguigu.java.HelloWorld")`；



# 双亲委派模型

## 定义与本质

类加载器用来把类加载到Java虚拟机中。从JDK1. 2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。

1. 定义
   ***如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。***
2. 本质
   ***规定了类加载的顺序是:引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。***

![image-20200705105151258](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-202007051052151258.png)

![image-20201116134825960](/Users/silince/Pictures/Typora/image-20201116134825960.png)

## 优势与劣势

1.双亲委派机制优势

- ***避免类的重复加载，确保一个类的全局唯一性；Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，***当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
- 保护程序安全，防止核心API被随意篡改

2.代码支持

双亲委派机制在`java.lang.ClassLoader.loadClass(String,boolean)`接口中体现。该接口的逻辑如下:

1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。

2）判断当前加载器的父加载器是否为空，如果不为空，则调用`parent.loadClass(name, false)`接口进行加载。

3）反之，如果当前加载器的父类加载器为空，则调用`findBootstrapClass0rNull(name)`接口，让引导类加载器进行加载。

4）如果通过以上3条路径都没能成功加载，则调用`findClass (name)`接口进行加载。该接口最终会调用
`java. lang.ClassLoader`接口的`defineClass`系列的`native`接口加载目标Java类。
双亲委派的模型就隐藏在这第2和第3步中。

3.举例

假设当前加载的是`java.lang.object`这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准 备加载`java.Jang.object`时，JVM默认 会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载



## 破坏双亲委派机制

### 机制1

### 机制2

### 机制3



## 热替换的实现



# 沙箱安全机制

## JDK1.0时期

## JDK1.1时期

## JDK1.2时期

## JDK1.6时期



# 自定义类的加载器

## 实现方式



# Java9新特性

