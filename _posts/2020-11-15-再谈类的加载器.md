---
layout: post
title:  "再谈类的加载器"
date:   2020-11-15 19:21:16 +0800--
categories: [JVM,]
tags: [Java, JVM, 类加载器]  

---

# 概述

类加载器是JVM执行类加载机制的前提。

***ClassLoader的作用:***

***ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的`java.lang. Class`对象实例。***然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由`Execution Engine`决定。

![image-20201115193256464](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201115193256464.png)

类加载器最早出现在Java1.0版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在0SGi、字节码加解密领域大放异彩。***这主要归功于Java虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。***



## 大厂面试题

蚂蚁金服:

- 深入分析ClassLoader，双亲委派机制
- 类加载器的双亲委派模型是什么？ 
- 一面:双亲委派机制及使用原因

百度:

- 都有哪些类加载器，这些类加载器都加载哪些文件？
- 手写一个类加载器Demo
- `Class的forName("java.lang.String")`和`Class的getClassLoader()``loadClass("java.lang.String")`有什么区别？

腾讯:

- 什么是双亲委派模型？
- 类加载器有哪些？

小米:

- 双亲委派模型介绍一下

滴滴:

- 简单说说你了解的类加载器
- 一面:讲一下双亲委派模型，以及其优点

字节跳动:

- 什么是类加载器，类加载器有哪些？

京东:

- 类加载器的双亲委派模型是什么？双亲委派机制可以打破吗？为什么



## 类加载的分类

***类的加载分类:显式加载 vs 隐式加载***

class文件的显式加载与隐式加载的方式是***指JVM加载class文件到内存的方式***：

- 显式加载指的 是在代码中通过调用ClassLoader加载class对象，如直接使用`Class.forName (name)`或
  `this.getClass().getClassLoader().loadClass()`加载class对象。
- 隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。

在日常开发以上两种方式一般会混合使用。

```java
public class UserTest {
    public static void main(String[] args) {
        User user = new User(); //隐式加载

        try {
            Class clazz = Class.forName("com.atguigu.java.User"); //显式加载
            ClassLoader.getSystemClassLoader().loadClass("com.atguigu.java.User");//显式加载
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

    }
}
```





## 类加载器的必要性

一.般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说:

- 避免在开发中遇到`java.lang.ClassNotFoundException异常`或`java.lang.NoClassDefFoundError异常`时手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题
- 需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。
- 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。



## 命名空间

1.何为类的唯一性？

对于任意一个类，***都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。***

每一个类加载器，都拥有一个独立的类名称空间:***比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。***否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，***只要加载他们的类加载器不同，那这两个类就必定不相等。***



2.命名空间

每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成

- 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
- 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

***⭐️ 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。***



## 类加载机制的基本特征

通常类加载机制有三个基本特征:

- ***双亲委派模型。 但不是所有类加载都遵守这个模型***，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的`ServiceProvider/ServiceLoader`机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、 JDBC、 文件系统、Cipher等很多方面，都是利用的这种机制，***这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。***
- ***可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。***不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。
- ***单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。***但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。



# 类加载器的分类

JVM支持两种类型的类加载器，分别为***引导类加载器（Bootstrap ClassLoader） 和自定义类加载器（User-Defined ClassLoader 包括扩展类和应用程序类加载器）。***

从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是***将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器***。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况:

- 除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。
- 不同类加载器看似是继承（ Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用

![image-20201115221621066](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201115221621066.png)





## 引导类加载器

启动类加载器（ 引导类加载器，Bootstrap ClassLoader），使用 `-Xx: +TraceClassLoading`参数可查看加载过程。

- 这个类加载使用***C/C++语言实现的，嵌套在JVM内部***
- 它用来加载Java的核心库（`JAVA_HOME/jre/lib/rt.jar`或`sun.boot.class.path`路径下的内容），用于提供JVM自身需要的类
- 并不继承自`java. lang. ClassLoader`， 没有父加载器
- ***出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、 sun等开头的类***
- ***加载扩展类和应用程序类加载器，并指定为他们的父类加载器***



## 扩展类加载器

扩展类加载器（Extension ClassLoader）

- Java语言编写，由`sun. misc. Launcher$ExtClassLoader`实现。
- 继承于`ClassLoader`类
- 父类加载器为启动类加载器
- 从`java. ext .dirs`系统属性所指定的目录中加载类库，或从JDK的安装目录的`jre/lib/ext`子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

![image-20201115223622669](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201115223622669.png)



## 系统类加载器

应用程序类加载器（系统类加载器，AppClassLoader）

- java语言编写，由`sun. misc. Launcher$AppClassLoader`实现
- 继承于`ClassLoader`类
- 父类加载器为扩展类加载器
- 它负责加载环境变量`classpath`或系统属性`java. class.path`指定路径下的类库
- ***应用程序中的类加载器默认是系统类加载器。***
- ***它是用户自定义类加载器的默认父加载器***
- 通过`ClassLoader`的`getSystemClassLoader()`方法可以获取到该类加载器



## 用户自定义类加载器

用户自定义类加载器：

- 在Java的日常应用程序开发中， 类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。
- 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。
- ***通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。***例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。
- ***同时，自定义加载器能够实现应用隔离，***例如Tomcat， Spring等中 间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。
- 自定义类加载器通常需要继承于ClassLoader。



# 测试不同的类加载器

每个Class对象都会包含一个定义它的ClassLoader的一个引用。

获取ClassLoader的途径：

- 获取当前类的ClassLoader：`clazz.getClassLoader()`
- 获取当前线程上下文的ClassLoader：`Thread.currentThread.getContextClassLoader()`
- 获取系统的ClassLoader：`ClassLoader.getSystemClassLoader()`

说明:

站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。***由于引导类加载器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。***

数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。***对于数组类的类加载器来说，是通过`Class.getClassLoader()`返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型是基本数据类型，数组类是没有类加载器的。***

```java
public class ClassLoaderTest1 {
    public static void main(String[] args) {
        //获取系统该类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
        //获取扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d
        //试图获取引导类加载器：失败
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);//null
      
        //###########################
        try {
            ClassLoader classLoader = Class.forName("java.lang.String").getClassLoader();
            System.out.println(classLoader); //null
            //自定义的类默认使用系统类加载器
            ClassLoader classLoader1 = Class.forName("com.atguigu.java.ClassLoaderTest1").getClassLoader();
            System.out.println(classLoader1);
          
            //关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同
            String[] arrStr = new String[10];
            System.out.println(arrStr.getClass().getClassLoader());//null:表示使用的是引导类加载器

            ClassLoaderTest1[] arr1 = new ClassLoaderTest1[10];
            System.out.println(arr1.getClass().getClassLoader());//sun.misc.Launcher$AppClassLoader@18b4aac2

            int[] arr2 = new int[10];
            System.out.println(arr2.getClass().getClassLoader());//null:不需要类的加载器

            System.out.println(Thread.currentThread().getContextClassLoader());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```





# ClassLoader源码解析

ClassLoader与现有类加载器的关系:

![image-20201116094658535](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20201116094658535.png)

除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类`java.lang.ClassLoader`，所有用户自定义的类加载器都应该继承`ClassLoader`类。



## ClassLoader的主要方法

***抽象类ClassLoader的主要方法（ 内部没有抽象方法）:*** 

1.返回该类加载器的超类加载器

- `public final ClassLoader getParent()`

2.加载名称为name的类，返回结果为`java. lang. Class类`的实例。如果找不到类，则返回`ClassNotFoundException`异常。***该方法中的逻辑就是双亲委派模式的实现。***

- `public Class<?> loadClass（String name） throws ClassNotFoundException`

```java
// 测试代码： ClassLoader.getSystemClassLoader().loadClass("cn.silince.User")
// 涉及到以下方法的调用：
protected Class<?> loadClass(String name, boolean resolve)
  throws ClassNotFoundException
{
  synchronized (getClassLoadingLock(name)) {
    // First, check if the class has already been loaded
    Class<?> c = findLoadedClass(name);
    if (c == null) {
      long t0 = System.nanoTime();
      try {
        if (parent != null) {
          c = parent.loadClass(name, false);
        } else {
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // ClassNotFoundException thrown if class not found
        // from the non-null parent class loader
      }

      if (c == null) {
        // If still not found, then invoke findClass in order
        // to find the class.
        long t1 = System.nanoTime();
        c = findClass(name);

        // this is the defining class loader; record the stats
        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
        sun.misc.PerfCounter.getFindClasses().increment();
      }
    }
    if (resolve) {
      resolveClass(c);
    }
    return c;
  }
}
```



3.查找二进制名称为name的类，返回结果为`java.lang.Class`类的实例。这是个受保护的方法， JVM鼓励我们重 写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被`loadClass()`方法调用。

- `protected Class<?> findClass（String name） throws ClassNotFoundException`



在JDK1.2之前，在自定义类加载时，总会去继承`ClassLoader`类并重写`loadClass`方法，从而实现自定义的类加载类。但是在JDK1. 2之后已不再建议用户去覆盖`loadClass()`方法，而是建议把自定义的类加载逻辑写在
`findClass()`方法中，从前面的分析可知，`findClass()`方法是在`loadClass()`方法中被调用的，当
`loadClass()`方法中父加载器加载失败后，则会调用自己的`findClass()`方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。

需要注意的是`ClassLoader`类中并没有实现`findClass()`方法的具体代码逻辑，取而代之的是抛出
`ClassNotFoundException`异常，同时应该知道的是`findClass `方法通常是和defineClass方法一起使用的。***一般情况下，在自定义类加载器时，会直接覆盖`ClassLoader的findClass()`方法并编写加载规则，取得要加载类的字节码后转换成流， 然后调用`defineClass()`方法生成类的Class对象。***



4.根据给定的字节数组b转换为Class的实例，`off`和`len`参数表示实际Class信息在byte数组中的位置和长度，其中，

- `protected final Class<?> defineClass（String name， byte[] b， int off， int len）`




## SecureClassLoader与URLClassLoader

## ExtClassLoader和AppClassLoader

## Class.forName()与ClassLoader.loadClass()



# 双亲委派模型

## 定义与本质

## 优势与劣势

## 破坏双亲委派机制

### 机制1

### 机制2

### 机制3



## 热替换的实现



# 沙箱安全机制

## JDK1.0时期

## JDK1.1时期

## JDK1.2时期

## JDK1.6时期



# 自定义类的加载器

## 实现方式



# Java9新特性

