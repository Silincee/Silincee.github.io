---
layout: post
title:  "我再也不怕写错二分查找啦（大概"
date:   2021-04-19 14:10:06 +0800--
categories: [数据结构]
tags: [数据结构, ]  


---

# 前言

之前看了labuladong的二分模版，以为自己懂了，结果遇到题目还是到处吃瘪，各种细节直接痛苦面具放弃思考 😭

最近看到一个讲二分查找的视频，感觉我又行了！特此记录一下该方法，主要思想就是：把红蓝区域固定，然后通过选择返回的r，l获得上界和下界，这样取区域与返回值可以更加灵活多变。

比如 在一段集合里 [1,2,3,5,5,5,8,9] 可以有四种情况 ，要如何进行二分的设计？

1. 找到第一个 `>=5` 的元素 
2. 找到最后一个`<5` 的元素 
3. 找到第一个 `>5 `的元素
4. 找到最后一个 `<=5` 的元素 

![image-20210419104749739](/assets/imgs/image-20210419104749739.png)



「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。



# 算法流程

对于一个数组，可以将二分查找任务转换为寻找其 `蓝红边界` ，即求出未知数K-1和K的位置。（target=5）

![image-20210419105129479](/assets/imgs/image-20210419105129479.png)

1）首先整个数组都是灰色的，蓝红指针为别初始化位-1和数组长度length。首先查看数组最中间的元素 `4` 为蓝色，所以将蓝色边界直接扩展到该元素所在位置。

![image-20210419105949499](/assets/imgs/image-20210419105949499.png)

2）继续上述步骤，观察灰色区域中最中间的元素 `6` 为红色，所以将红色指针扩展到该元素所在的位置。

![image-20210419110149133](/assets/imgs/image-20210419110149133.png)

3）一直重复执行上述操作，最后就能够找到蓝红边界：

![image-20210419110252619](/assets/imgs/image-20210419110252619.png)



# 伪代码

- 初始：`l` 指向蓝色区域， `r` 指向红色区域
- 循环： `l` 、 `r`  快速向蓝红边界逼近，**并保持  `l` 、 `r`   颜色不改变**
- 结束： `l` 、 `r`  刚好指向蓝红边界

```java
l = -1, r = N // 首先初始化两个指针，l指向-1，r指向数组长度N
while (l+1 ！= r){ // 循环直至l+1 = r
  m = (l+r)/2 // 求出灰色数组中间元素的位置，并向下取整（注意溢出）
  if isBlue(m) l = m // 如果l的颜色为蓝色，就把蓝色区域拓展到m (把 m 赋值给 左指针)
  else r = m // 否则红色区域扩展到m (把m赋值给右指针)
}
return l or r  // 此时的l和r刚刚好指向蓝红边界，可以根据实际情况返回l还是r
```

防止溢出：

```java
if(x == Integer.MAX_VALUE){
  m = (right+left)/2;
}else{
  m = (right-left)/2+left;
}
// 或者直接用long接收 然后转换为int
Integer.parseInt(String.valueOf(m))
```



# 查找元素不存在怎么办

> 因为left指针始终在right指针之后，查找上界时会存在三种情况（此时返回的是right指针）：

-  [5,6,8,8,9] target = 1 => right = 0 （此时nums[right]!=target）
-  [5,6,8,8,9] target = 10 => right = nums.length（越界了）
-  [5,6,8,8,9] target = 7 => right = 2 (如果target在数组中的话，会返回刚好大于target的值。同样的，此时nums[right]!=target)

```java
int left = -1;
int right = nums.length;

while (left + 1 != right) {
  int m = (left + right) / 2;
  if (nums[m]<target){
    left = m;
  }else {
    right=m;
  }
}
if (right==nums.length||nums[right]!=target){
  right = -1;
}
return right;
```

> 查找下界时，返回的left指针，同样也是三种情况：

-  [5,6,8,8,9] target = 1 => left = -1 （越界了）
-  [5,6,8,8,9] target = 10 => left = nums.length-1（此时nums[right]!=target）
-  [5,6,8,8,9] target = 7 => left = 1 (如果target在数组中的话，会返回刚好小于target的值。同样的，此时nums[right]!=target)

```java
int left = -1;
int right = nums.length;

while (left + 1 != right) {
  int m = (left + right) / 2;
  if (nums[m]<=target){
    left = m;
  }else {
    right=m;
  }
}

if (left==-1||nums[left]!=target){
  left=-1;
}
return left;
```





# 细节问题

> 细节1：为什么 l 的初始值为-1 ，r 的初始值为 N

当l初始化为0的情况下，如果整个数组都是红色，l一开始则会落于红色区域内。r初始化为N-1同理。

![image-20210419133318776](/assets/imgs/image-20210419133318776.png)



> 细节2：m 是否是种处于[0,N)的左闭右开区间以内

只有`m`属于[0,N)的左闭右开区间以内，isBlue(m) 判断颜色才是有意义的。

先来看`m`的下界：因为 `m = (l+r)/2`, 只要让`l`、`r`尽可能的小即可。`l`的最小值即为他的初始值`-1`，对于`r` 而言，如果他能进入循环体，他的最小值为`1`。 因此`m`的最小值即为 `(-1+1)/2=0`。

再来看`m`的上界：要让`l`、`r`尽可能的大即可，`r` 的最大值为 N， `l` 则为N-2 ， `m` 的最大值则为 N-1。

因此 `m` 始终处于于[0,N)的左闭右开区间以内，即`m`不会溢出。

> 细节3：更新指针的时候，能不能写成 l = m +1 或者 r = m - 1

对于下图的情况，在某次循环中`m`刚刚好指向蓝色区域的最后一个元素，如果 `l = m +1` 就会让l指向红色区域造成了错误。` r = m - 1`同理。

![image-20210419134458329](/assets/imgs/image-20210419134458329.png)

> 细节4：程序会不会陷入死循环

无论`l`和`r` 之间隔了多少个元素，都一定会退化到第一种情况并退出循环。

 ![image-20210419135430099](/assets/imgs/image-20210419135430099.png)



# 总结

对于前言中的问题，结合以上分析可归纳出二分查找设计的一般流程：

- 建模：划分蓝红区域，确定 `isBlue()`函数的条件
- 确定返回`l` 还是 `r`
- 套用伪代码模版
- 如果有需要则加入一下后处理逻辑

![image-20210419140058088](/assets/imgs/image-20210419140058088.png)





```java
// case1: 寻找第一个 >=5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right-left)/2 + left; // 因为left=-1，所以还是可能会溢出
    if (arr[m]<5){
      left = m;
    }else {
      right = m;
    }

  }
  return right;
}
// case2: 寻找最后一个 <5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right+left)/2;
    if (arr[m]<5){
      left = m;
    }else {
      right = m;
    }

  }
  return left;
}
// case3: 寻找第一个 >5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right+left)/2;
    if (arr[m]<=5){
      left = m;
    }else {
      right = m;
    }

  }
  return right;
}
// case4: 寻找最后一个 <=5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right+left)/2;
    if (arr[m]<=5){
      left = m;
    }else {
      right = m;
    }

  }
  return right;
}
```



# 刷题时间

## [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

返回类型是只保留整数部分，那么不就是要我们找到 $mid<=\sqrt{x}$的上界吗

- 扩大蓝色的条件：`m*m<=x` 都属于蓝色
- 返回`l` 

```java
public int mySqrt(int x) {
  if (x==0) return 0;
  if (x==1) return 1;

  int left = -1;
  int right = x;
  int m = 0;

  while (left+1!=right){
    if(x == Integer.MAX_VALUE){
      m = (right+left)/2;
    }else{
      m = (right-left)/2+left;
    }
    
    if ((long)m*m<=x){
      left = m;
    }else {
      right = m;
    }

  }
  return left;
}
```

## [第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

找到第一个true：

- 扩大蓝色的条件：m= flase (表示错误的版本)
- 返回`right` 

```java
0---------------first--------------N
      mid       mid       mid
     false      true      true
```

```java
public int firstBadVersion(int n) {
  long left = -1;
  long right = (long)n+1;

  while(left+1!=right){
    long m = (right-left)/2+left;
    if(isBadVersion(Integer.parseInt(String.valueOf(m)))==false){
      left = m;
    }else{
      right=m;
    }
  }
  return Integer.parseInt(String.valueOf(right));
}
```

## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

查找元素的第一个位置： [5,7,7,8,8,9] target=8

- 扩大蓝色的条件：nums[m]<8
- 返回`right` 
- 注意不存在的场景：`right==nums.length||nums[right]!=target`

查找元素的最后一个位置：

- 扩大蓝色的条件：nums[m]<=8
- 返回`left` 
- 注意不存在的场景：`left==-1||nums[left]!=target`

```java
public int[] searchRange(int[] nums, int target) {
  int[] res = new int[2];

  // 找上界
  int left = -1;
  int right = nums.length;

  while (left + 1 != right) {
    int m = (left + right) / 2;
    if (nums[m]<target){
      left = m;
    }else {
      right=m;
    }
  }
  if (right==nums.length||nums[right]!=target){
    res[0] = -1;
  }else {
    res[0] = right;
  }


  // 找下界
  left = -1;
  right = nums.length;

  while (left + 1 != right) {
    int m = (left + right) / 2;
    if (nums[m]<=target){
      left = m;
    }else {
      right=m;
    }
  }

  if (left==-1||nums[left]!=target){
    res[1] = -1;
  }else {
    res[1] = left;
  }

  return res;
}
```

## [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) ⭐️

- **「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。**

- 经过旋转的数组，显然前半段满足 `>= nums[0]`，而后半段不满足 `>= nums[0]`。我们可以以此作为依据来划分蓝红区间。
- 扩大蓝色的条件：`nums[m]>= nums[0]`
- 返回`right` 

```java
public int findMin(int[] nums) {
  int left = -1;
  int right = nums.length;

  while (left+1!=right){
    int m = (right-left)/2+left;

    if (nums[m]>=nums[0]){ // 记得有=号，特殊case[2,1]
      left = m;
    }else {
      right = m;
    }
  }

  if (right==nums.length) return nums[0]; // 旋转了一圈回来了,如[1,2,3,4]

  return nums[right];
}
```

## [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/description/) ⭐️

- 不同的是，本题元素并不唯一。
- 这意味着我们无法直接根据与 nums[0] 的大小关系，将数组划分为两段，即无法通过「二分」来找到旋转点。因为「二分」的本质是二段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。
- 但如果旋转点使得相同元素进行了分裂将会失去两段性，如`[01222345] =>[23450122]`。我们需要做一些预处理操作，使得其二段性恢复方便我们通过「二分」找旋转点。**我们可以将新数组尾部与nums[0]相同的元素忽略使得其二段性恢复。**

- 预处理：**删除数组末尾上所有与nums[0]相同的数，即把right指针指到最后一个等于nums[0]的数。然后继续划分红蓝区间：**
- 扩大蓝色的条件：`nums[m]>= nums[0]`
- 返回`right` 

```java
public int findMin(int[] nums) {
  int left = -1;
  int right = nums.length;

  while (right>0 && nums[0] == nums[right-1]) right--;

  while (left+1!=right){
    int m = (right-left)/2+left;

    if (nums[m]>=nums[0]){
      left = m;
    }else {
      right = m;
    }
  }

  if (right==nums.length) return nums[0];

  return nums[right];
}
```



## [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)