---
scrolllayout: post
title:  "Mysql数据库高级"
date:   2020-08-20 19:02:06 +0800--
categories: [数据库]
tags: [mysql, ]  
---

# Mysql数据库高级

> https://blog.csdn.net/Pzzzz_wwy/article/details/106600571   建表语句

## Mysql逻辑架构简介

![image-20200821144944995](/assets/imgs/image-20200821144944995.png)

和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。***主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离***。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

### 连接层

最上层是一些客户端和连接服务，包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的 通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证 安全接入的客户端提供线程。同样在该层上可以实现基于 SSL 的安全链接。服务器也会为安全接入的每个客户端验 证它所具有的操作权限。

### 服务层

管理服务和实用程序：

- SQL Interface:SQL 接口。接受用户的 SQL 命令，并且返回用户需要查询的结果。比如 select from 就是调用 SQL Interface
- Parser：解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析
- Optimizer：查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有 where 条件时，优化器来决定先投影还是先过滤。
- Cache 和 Buffer：查询缓存。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取 数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。

### 引擎层

存储引擎层，存储引擎真正的负责了 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。

MyISAM和InnoDB对比：

| 对比项   | MyISAM                                                   | InnoDB                                                       |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 主外键   | 不支持                                                   | 支持                                                         |
| 事务     | 不支持                                                   | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 | 行锁，操作时只锁定某一行，不对其他行有影响；***适合高并发的操作*** |
| 缓存     | 只缓存索引，不缓存真实数据                               | 不仅缓存索引还缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 表空间   | 小                                                       | 大                                                           |
| 关注点   | 性能                                                     | 事务                                                         |
| 默认安装 | Y                                                        | Y                                                            |

### 存储层

数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。

## sql回顾

### sql的执行顺序

```sql
-- 手写的顺序
select distinct <select_list> 
from <left_table> <join_type>
join <right_table> on <join_condition>
where <where_condition>
group by <group_by_list>
having <having_condition>
order by <order_by_condition>
limit <limit_number>
-- 机读的顺序,优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序.下面是经常出现的查询顺序:
from <left_table>
on <join_condition>
<join_type> join <right_table>
where <where_condition>
group by <group_by_list>
having <having_condition>
select 
distinct <select_list> 
order by <order_by_condition>
limit <limit_number>
```

![image-20200821161733475](/assets/imgs/image-20200821161733475.png)

### 常见的Join查询

![image-20200821162038942](/assets/imgs/image-20200821162038942.png)

***其中mysql不支持外连接，6 = 1 union 2; 7 = 4 union 5。***

## 索引优化分析

### 性能下降原因

- 查询语句写的烂
- 索引失效
- 关联查询太多join（设计缺陷或不得已的需求）
- 服务器调优及各个参数设置（缓冲、线程数等）

### 索引的概念

MySQL 官方对索引的定义为:索引(Index)是帮助 MySQL 高效获取数据的数据结构。可以得到索引的本质: 索引是数据结构。**可以简单理解为排好序的快速查找数据结构**。

***在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据， 这样就可以在这些数据结构上实现高级查找算法。***这种数据结构，就是索引。下图就是一种可能的索引方式示例:

![image-20200821193524898](/assets/imgs/image-20200821193524898.png)

左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个 右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。

***一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。***

***我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。***其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引等。

**索引的优缺点**

优势:

- 提高数据***检索***的效率，降低数据库的IO成本。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

劣势:

- 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要***占用空间*** 的。

### 索引的分类

- 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引

- 唯一索引：索引列的值必须唯一，但允许有空值

- 主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引

- 复合索引：即一个索引包含多个列

**基本语法**

```sql
-- 创建索引
CREATE [UNIQUE ] INDEX [indexName] ON table_name(columnname(length));
ALTER table_name ADD [UNIQUE] index [indexName] ON (columnname(legnth));

-- 删除索引
DROP INDEX [indexName] ON table_name;

-- 查看索引
SHOW INDEX FROM table_name\G;

-- 添加数据表的索引
-- 主键索引：该语句添加一个主键，这意味着索引值必须是唯一的，且不能为 NULL。
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);
-- 唯一索引：这条语句创建索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)。
ALTER TABLE tbl_name ADD UNIQUE KEY (column_list);
-- 普通索引：索引值可出现多次。
ALTER TABLE tbl_name ADD INDEX index_name (column_list);
-- 全文索引：该语句指定了索引为 FULLTEXT ，用于全文索引。
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);
```

### Mysql索引结构

- Hash索引

- full-text全文索引

- R-tree索引
- Btree索引

MySQL 使用的是 Btree 索引。

![image-20200821203835531](/assets/imgs/image-20200821203835531.png)

**初始化介绍：**

一颗 b 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项(深蓝色所示)和指针(黄色所示)，如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3， P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。 ***真实的数据存在于叶子节点***即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。 ***非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项***，如 17、35 并不真实存在于数据表中。

**查找过程：**

如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短(相比磁盘的 IO)可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指 针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。

真实的情况是，3 层的 B 树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的， 如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。

### 索引的创建时机

**适合创建索引的情况：**

-  主键自动建立唯一索引;
-  频繁作为查询条件的字段应该创建索引
-  查询中与其它表关联的字段，外键关系建立索引
-  单键/组合索引的选择问题（在高并发下倾向于创建组合索引）
-  查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
-  查询中统计或者分组字段

**不适合创建索引的情况：**

- 表记录太少
- 频繁增删改的表或者字段
- Where条件里用不到的字段不创建索引
- 过滤性不好（重复率过高）的不适合建索引

### 性能分析：

#### Mysql Query Optimizer

#### mysql常见瓶颈

- CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读出数据的时候
- IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候
- 服务器硬件的性能瓶颈：top,free,iosat和vmstat来查看系统的性能状态

#### Explain

使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分 析你的查询语句或是表结构的性能瓶颈。

##### **能干嘛**：

- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询

##### **如何使用：**

用法: Explain+SQL 语句。

Explain 执行后返回的信息:

![image-20200821220646626](/assets/imgs/image-20200821220646626.png)

##### **字段解释：**

- **id：select 查询的序列号,包含一组数字，表示查询中执行 select 子句或操作表的顺序。**

  - id 相同，执行顺序由上至下

    ![image-20200821222934865](/assets/imgs/image-20200821222934865.png)

  - id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行

    ![image-20200821223006571](/assets/imgs/image-20200821223006571.png)

  - 有相同也有不同；id 如果相同，可以认为是一组，从上往下顺序执行;在所有组中，id 值越大，优先级越高，越先执行。衍生 = DERIVED

  - 关注点：id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。

- **select_type：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。**
  - **SIMPLE**	简单的 select 查询,查询中不包含子查询或者 UNION
  - **PRIMARY**    查询中若包含任何复杂的子部分，最外层查询则被标记为 Primary
  - **DERIVED**    在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里。
  - **SUBQUERY**    在SELECT或WHERE列表中包含了子查询
  - **DEPEDENT SUBQUERY**    在SELECT或WHERE列表中包含了子查询,子查询基于外层
  - **UNCACHEABLE SUBQUERY**    无法使用缓存的子查询
  - **UNION**    若第二个SELECT出现在UNION之后，则被标记为UNION; 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为:DERIVED
  - **UNION RESULT**    从UNION表获取结果的SELECT

- **table：这个数据是基于哪张表的。**
- **type：查询的访问类型。**
  - **system**：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计
  - **const**：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，mysql就能将该查询转换为一个常量。
  - **eq_ref**：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
  - **ref**： 非唯一性索引扫描，返回匹配某个单独值的所在行。本质上也是一种索引访问，它返回所以匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。
  - **range**：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪些索引。一般就是在你的where语句中出现了between、<、>、in等的查询。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
  - **index**：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读取的）
  - **all**：Full  Table Scan，将遍历全表以找到匹配的行
  - 结果值从最好到最坏依次是***system > const > eq_ref > ref > range > index >ALL***，一般来说，得保证查询***至少达到 range 级别，最好能达到 ref(在百万或千万级别的查询下)。***完整版：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index >ALL。
- **possible_keys**：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，***但不一 定被查询实际使用。***
- **key**：实际使用的索引。如果为NULL，则没有使用索引；***查询中若使用了覆盖索引，则该索引仅出现在key列表中。***

- **ref**：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。
- **rows**：显示 MySQL 认为它执行查询时必须检查的行数；根据表统计信息及索引选用情况，大致估算出找到所需记录所需要读取的行数。***越少越好!***
- **Extra**：其他的额外重要的信息。
  - ***Using filesort*** 🙅：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。
  - ***Using temporary* 🙅：**使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。
  - ***Using index：***🉑️
    - Using index 代表表示相应的 select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错!   ***覆盖索引：就是select的数据列只用从索引就能够取得，不必读取数据行，mysql可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。*** 使用时需要注意：
      - 一点要注意select列表中只取出需要的列，不可select *
      - 因为如果将所有字段一起做索引会导致索引文件过大，导致查询性能下降
    - 如果同时出现 using where，表明索引被用来执行索引键值的查找;
    - 如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。
  - **Using where：**表明使用了 where 过滤。
  - **Using join buffer：**使用了连接缓存。
  - **impossible where：**where 子句的值为 false，不能用来获取任何元组。
  - **select tables optimized away：**在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。
  - **distinct：**优化distinct操作，在找到第一匹配的原组后即停止找同样值的动作。
- **key_len**：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 
  - key_len 字段能够帮你检查是否充分的利用上了索引。key_len 越长，说明索引使用的越充分。
  - 在不损失精度的情况下，长度越短越好。
  - key_len显示的值为索引字段的最大可能长度，***并非实际使用长度***，即key_len是根据表定义计算而得，不是通过表内检索出的。

**key_len的计算：**

![image-20200823143313951](/assets/imgs/image-20200823143313951.png)

![image-20200823143324720](/assets/imgs/image-20200823143324720.png)

1. 先看索引上字段的类型+长度比如 int=4 ; varchar(20) =20 ; char(20) =20 
2. 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8  要乘 3,GBK 要乘 2，
3.  varchar 这种动态字符串要加 2 个字节 
4. 允许为空的字段要加 1 个字节

第一组:key_len=age 的字节长度+name 的字节长度=4+1 + ( 20*3+2)=5+62=67 
第二组:key_len=age 的字节长度=4+1=5

![image-20200823143542304](/assets/imgs/image-20200823143542304.png)

##### 热身Case:

写出以下sql对应的执行顺序：

![image-20200823161144627](/Users/silince/Develop/博客/blog_to_git/assets/imgs/image-20200823161144627.png)

ANSWER：

1. select_type 为union，说明第四个select是union里的第二个select，最先执行`select name, id from t2`
2. id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived`select id,name frin t1 where other_cloumn=`
3. select列表中的值查询select_type为subquery，为整个查询中的第二个select`select name,id from t2`
4. id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为`<derived3>` , 表示查询结果来自一个衍生表，其中3代表该查询衍生自第三个select查询，即id为3的select `select d1.name...`

5. 代表从union的临时表中读取行的阶段，table列的`<union1,4>`表示用第一个和第四个select的结果进行union操作 `两个结果的union操作`

