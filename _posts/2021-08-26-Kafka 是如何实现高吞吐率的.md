---
layout: post
title: "Kafka 是如何实现高吞吐率的"
date: 2021-08-26 17:11:16 +0800--
categories: [Java, ]
tags: [消息队列, Kafka,]  

---

Kafka是分布式消息系统，需要处理海量的消息，Kafka的设计是把所有的消息都写入速度低容量大的硬盘，以此来换取更强的存储能力，但实际上，使用硬盘并没有带来过多的性能损失。kafka主要使用了以下几个方式实现了超高的吞吐率：

# 顺序读写

> Kafka数据不是实时写入硬盘，采用内存映射文件(分页存储)来利用内存提高I/O效率，利用操作系统的页来实现物理内存映射，映射完后物理内存上的操作会被同步到硬盘上。

kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能。

**顺序读写不需要硬盘磁头的寻道时间**，只需很少的扇区旋转时间，所以速度远快于随机读写。

Kafka官方给出了测试数据(Raid-5，7200rpm)：

- 顺序 I/O: 600MB/s

- 随机 I/O: 100KB/s

# 零拷贝

> 详细可阅读：[JAVA NIO 与零拷贝](http://www.silince.cn/2020/09/28/Java-NIO/#nio%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D)

零拷贝：减少了系统的两次上下文切换，

- 原来：文件复制到系统内核空间---复制到用户空间---复制到内核空间--发送网卡，使用socket发送。
- 现在：直接从内核空间到内核空间---发送给网卡

先简单了解下文件系统的操作流程，例如一个程序要把文件内容发送到网络。这个程序是工作在用户空间，文件和网络socket属于硬件资源，两者之间有一个内核空间。在操作系统内部，整个过程为：

![image-20210827102717638](/assets/imgs/image-20210827102717638.png)

在Linux kernel2.2 之后出现了一种叫做"零拷贝(zero-copy)"系统调用机制，就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区”

**系统上下文切换减少为2次，可以提升一倍的性能**

![image-20210827102751009](/assets/imgs/image-20210827102751009.png)



# 文件分段

> kafka的队列topic被分为了多个区partition，每个partition又分为多个段segment，每个segment段对应一个文件。

所以一个队列中的消息实际上是保存在N多个片段文件中的。

通过分段的方式，每次文件操作都是对一个小文件的操作，非常轻便，同时也增加了并行处理能力。

![image-20210827102856842](/assets/imgs/image-20210827102856842.png)



# 批量发送

> 缓存在内存中，达到阈值或者时间，则发送，减少了网络I/O。

Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去。

比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去：

- 如100条消息就发送，或者每5秒发送一次

- 这种策略将大大减少服务端的I/O次数

# 数据压缩 

> GZIP、Snappy，减少了磁盘I/O和网络的I/O

Kafka还支持对消息集合进行压缩，Producer可以通过**GZIP或Snappy格式**对消息集合进行压缩

压缩的好处就是减少传输的数据量，减轻对网络传输的压力

Producer压缩之后，**在Consumer需进行解压**，虽然增加了CPU的工作，但在对大数据处理上，瓶颈在网络上而不是CPU，所以这个成本很值得。

