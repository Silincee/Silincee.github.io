---
layout: post
title:  "什么是线程安全?如何实现？"
date:   2021-04-21 21:10:06 +0800--
categories: [操作系统]
tags: [操作系统, ]  


---

# 前言

前几天面试，面试官直接问了“什么是线程安全？”，突如其来这么宽泛的一个问题，当时讲的很没有逻辑🤯。特此重新梳理和记录一下操作系统中多线程的基本知识。



# 什么是线程安全

目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。

假设某个线程把数据处理到一半，觉得很累，就去休息了一会，回来准备接着处理，却发现数据已经被修改了，不是自己离开时的样子了。可能被其它线程修改了。

**所以线程安全指的是，在多个线程同时访问共享资源时，无论怎么更改线程的执行顺序都不会出现数据不一致或者数据污染的情况。**



# 如何保证线程安全

## 位置隔离

采用局部变量，操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。这也是由操作系统保障的。

局部变量就可以放入线程的栈内存中来保证不同线程之间数据的隔离。



## 只读标记

把共享资源设置为只能读取，不能修改。其实就是常量(final)或只读变量，它们对于多线程是安全的，想改也改不了。



## 数据隔离

因为你放东西的“位置”只有你自己知道，所以这些东西是安全的，因此这份安全是由“位置”来保障的。

**现实中往往会有一个变量需要多个方法都能够使用的情况，**此时定义这个变量的“位置”就不能在方法里面了，而应该在方法外面。即从（方法的）局部变量变为（类的）成员变量，其实就是“位置”发生了变化。数据由一个私有区域来到了公共区域，潜在的安全风险也随之而来。

要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。此时就可以用ThreadLocal来实现线程之间数据的隔离。



## 同步互斥锁/阻塞同步锁/悲观锁

Synchorized/ReentrantLock

简单的说互斥就是非你即我，同步就是顺序访问。互斥同步锁就是以互斥的手段达到顺序访问的目的。操作系统提供了很多互斥机制比如信号量，互斥量，临界区资源等来控制在某一个时刻只能有一个或者一组线程访问同一个资源。





## 非阻塞同步锁/乐观锁

非阻塞同步锁也叫乐观锁，相比悲观锁来说，它会先进行资源在工作内存中的更新，然后根据与主存中旧值的对比来确定在此期间是否有其他线程对共享资源进行了更新，如果旧值与期望值相同，就认为没有更新，可以把新值写回内存，否则就一直重试直到成功。它的实现方式依赖于处理器的机器指令：CAS（Compare And Swap）JUC中提供了几个Automic类以及每个类上的原子操作就是乐观锁机制。



## volatile 

volatile实现内存的可见性，不过由于它不保证操作的原子性。因此只要保证只对共享变量进行原子操作即可实现线程安全。





# 同步互斥的实现

同步与互斥是两种不同的概念：

- 同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；
- 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；

为了实现进程/线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：

- 锁：加锁、解锁操作；（只能实现互斥）
- 信号量：P、V 操作； （能实现同步和互斥）

这两个都可以方便地实现**进程/线程互斥**，而信号量比锁的功能更强一些，它**还可以**方便地实现**进程/线程同步**。



## 锁

使用加锁操作和解锁操作可以解决并发线程/进程的互斥问题。

任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。



## 信号量

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。信号量其实是一个整型的计数器，主要用于实现进程/线程间的**互斥与同步**。

信号量表示资源的数量，控制信号量的方式有两种原子操作。P 操作是用在进入临界区之前，V 操作是用在离开临界区之后，这两个操作是必须成对出现的：

- 一个是 **P 操作**，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
- 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；



> 信号量实现临界区的互斥访问

为每类共享资源设置一个信号量 `s`，**其初值为 `1`，**表示该临界资源未被占用。

只要把进入临界区的操作置于 `P(s)` 和 `V(s)` 之间，即可实现进程/线程互斥：

![图片](/assets/imgs/640-9017344..png)

此时，任何想进入临界区的线程，必先在互斥信号量上执行 P 操作，在完成对临界资源的访问后再执行 V 操作。由于互斥信号量的初始值为 1，故在第一个线程执行 P 操作后 s 值变为 0，表示临界资源为空闲，可分配给该线程，使之进入临界区。

若此时又有第二个线程想进入临界区，也应先执行 P 操作，结果使 s 变为负值，这就意味着临界资源已被占用，因此，第二个线程被阻塞。

并且，直到第一个线程执行 V 操作，释放临界资源而恢复 s 值为 0 后，才唤醒第二个线程，使之进入临界区，待它完成临界资源的访问后，又执行 V 操作，使 s 恢复到初始值 1。

对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：

- 如果互斥信号量为 1，表示没有线程进入临界区；
- 如果互斥信号量为 0，表示有一个线程进入临界区；
- 如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入。

通过互斥信号量的方式，就能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。



> 信号量实现临界区的同步访问

同步的方式是为每个线程都设置一个信号量，**其初值为 `0`。**

我们把前面的「吃饭-做饭」同步的例子，用代码的方式实现一下：

妈妈一开始询问儿子要不要做饭时，执行的是 `P(s1)` ，相当于询问儿子需不需要吃饭，由于 `s1` 初始值为 0，此时 `s1` 变成 -1，表明儿子不需要吃饭，所以妈妈线程就进入等待状态。

当儿子肚子饿时，执行了 `V(s1)`，使得 `s1` 信号量从 -1 变成 0，表明此时儿子需要吃饭了，于是就唤醒了阻塞中的妈妈线程，妈妈线程就开始做饭。

接着，儿子线程执行了 `P(s2)`，相当于询问妈妈饭做完了吗，由于 `s2` 初始值是 0，则此时 `s2` 变成 -1，说明妈妈还没做完饭，儿子线程就等待状态。

最后，妈妈终于做完饭了，于是执行 `V(s2)`，`s2` 信号量从 -1 变回了 0，于是就唤醒等待中的儿子线程，唤醒后，儿子线程就可以进行吃饭了。