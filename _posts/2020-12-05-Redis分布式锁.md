---
layout: post
title: "Redis分布式锁"
date: 2020-12-05 14:31:16 +0800--
categories: [Java, 数据库]
tags: [Java, 分布式, redis,]  

---

# 概述

分布式锁：分布式微服务架构，拆分后各个微服务之间避免冲突和数据故障而加入的一种锁

JVM层面的加锁：单机版的锁

如何实现：

1. mysql
2. zookeeper
3. redis

一般的互联网公司，大家都习惯用redis做分布式锁 (redis --- redlock ===> redisson lock/unlock)



# 常见面试题

- Redis除了拿来做缓存，你还见过基于Redis的什么用法?
- Redis做分布式锁的时候有需要注意的问题?
- 如果是Redis是单点部署的，会带来什么问题?那你准备怎么解决单点问题呢?
- 集群模式下，比如主从模式，有没有什么问题呢?
- 那你简单的介绍一下Redlock吧?你简历上写redisson，你谈谈
- Redis分布式锁如何续期?看门狗知道吗?



# 基础案例

> [code](https://github.com/Silincee/interview-questions/tree/main/大厂面试题第二季/boot_redis01)

1）使用场景

多个服务间保证同一时刻同一时间段内同一用户只能有一个请求(防止关键业务出现并发攻击)

2）建Module   boot_redis01/boot_redis02

3）改POM

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.3.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.silince</groupId>
    <artifactId>boot_redis01</artifactId>
    <version>0.0.1-SNAPSHOT</version>

    <properties>
        <java.version>1.8</java.version>
    </properties>


    <dependencies>
        <!--web+actuator-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!--SpringBoot与Redis整合依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>

        <!--jedis-->
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!--springboot-aop技术-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <!--redisson-->
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson</artifactId>
            <version>3.13.4</version>
        </dependency>

        <!--一般通用基础配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

</project>
```

4）写YML

```properties
server.port=1111

# =========redis相关配置================
# Redis数据库索引（默认为0）
spring.redis.database=0
# Redis 服务器地址
spring.redis.host=localhost
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接池最大连接数（使用负值表示没有限制）默认 8
spring.redis.lettuce.pool.max-active=8
# 连接池最大阻塞等待时间（使用负值表示没有限制）默认 -1
spring.redis.lettuce.pool.max-wait=-1
# 连接池中的最大空闲连接默认8
spring.redis.lettuce.pool.max-idle=8
# 连接池中的最小空闲连接默认0
spring.redis.lettuce.pool.min-idle=0
```

5）主启动

```java
package cn.silince.redis;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BootRedis01Application {
    public static void main(String[] args) {
        SpringApplication.run(BootRedis01Application.class, args);
    }
}
```

6）业务类

- RedisConfig.java

```java
package cn.silince.redis.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.io.Serializable;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory connectionFactory){
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(connectionFactory);

        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        return redisTemplate;
    }

}
```

- GoodController.java

```java
package cn.silince.redis.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class GoodController {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Value("${server.port}")
    private String serverPort;

    @GetMapping("/buy_goods")
    public String buy_Goods() {
        String result = stringRedisTemplate.opsForValue().get("goods:001");// get key === 看看库存数量够不够
        int goodsNumber = result == null ? 0 : Integer.parseInt(result);

        if (goodsNumber > 0) {
            int realNumber = goodsNumber - 1;
            stringRedisTemplate.opsForValue().set("goods:001", String.valueOf(realNumber));
            System.out.println("成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort);

            return "成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort;
        }else {
            System.out.println("商品已经售完/活动结束/调用超时"+"\t 服务提供端口" + serverPort);
            return "商品已经售完/活动结束/调用超时"+"\t 服务提供端口" + serverPort;
        }

    }
}
```



7）测试

![image-20210111170659476](/assets/imgs/image-20210111170659476.png)

![image-20210111170715167](/Users/silince/Pictures/Typora/image-20210111170715167.png)



# 以上案例存在的问题

## 1.单机版没加锁

**问题：**

没有加锁，并发下数字不对，出现超卖现象

**解决方案：**

- 加synchronized (不见不散)，适用于一定要拿到锁的业务场景，容易造成线程积压
- 加ReentrantLock (过时不候)，线程等待的时间太长可以放弃等待或者给定一个时间，期间拿不到锁就放弃

```java
@RestController
public class GoodController {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Value("${server.port}")
    private String serverPort;

    private ReentrantLock lock = new ReentrantLock();

    @GetMapping("/buy_goods")
    public String buy_Goods() throws InterruptedException {

        if (lock.tryLock(3, TimeUnit.SECONDS)) {
            try {
                String result = stringRedisTemplate.opsForValue().get("goods:001");// get key === 看看库存数量够不够
                int goodsNumber = result == null ? 0 : Integer.parseInt(result);

                if (goodsNumber > 0) {
                    int realNumber = goodsNumber - 1;
                    stringRedisTemplate.opsForValue().set("goods:001", String.valueOf(realNumber));
                    System.out.println("成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort);

                    return "成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort;
                }else {
                    System.out.println("商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort);
                    return "商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort;
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
                return "error " + serverPort;
            }
        } else {
            return "获取锁超时" + serverPort;
        }
    }
}
```

在单机环境下，可以使用synchronized或Lock来实现。

但是在分布式系统中，因为竞争的线程可能不在同一个节点上(同一个jvm中），所以需要一个让所有进程都能访问到的锁来实现，比如redis或者zookeeper来构建;

不同进程jvm层面的锁就不管用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程。



## 2.nginx分布式微服务架构

**问题：**

分布式部署后，单机锁还是出现超卖现象，需要分布式锁

![image-20210111192323126](/assets/imgs/image-20210111192323126.png)

**环境配置：**

1）[Nginx配置负载均衡](http://www.silince.cn/2019/11/29/nginx/#负载均衡-1)

```
# redis 分布式锁测试
upstream mynginx{
    server 127.0.0.1:1111 weight=1;
    server 127.0.0.1:2222 weight=1;
}
server {
    listen       80;
    server_name  localhost;
    
    location / {
        proxy_pass http://mynginx;
        index index.html index.htm;
    }
}
```

访问:http://localhost/buy_goods ，可以点击看到效果，一边一个，默认轮询

2）[Jmeter压测](http://www.silince.cn/2020/11/23/Jmeter压测/)

99号商品被卖了两次！

![image-20210111200705886](/assets/imgs/image-20210111200705886.png)

![image-20210111200438582](/assets/imgs/image-20210111200438582.png)



**解决方案：**

上redis分布式锁setnx(redis天生就是单线程的)。

[Redis](https://redis.io/commands/set)具有极高的性能，且其命令对分布式锁支持友好，借助SET命令即可实现加锁处理。

![image-20210111201454951](/assets/imgs/image-20210111201454951.png)

修改后代码：

⚠️ 出异常的话，可能无法释放锁， 必须要在代码层面finally释放锁 

```java
@RestController
public class GoodController {

    public static final String REDIS_LOCK = "silince";

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Value("${server.port}")
    private String serverPort;

    private ReentrantLock lock = new ReentrantLock();

    @GetMapping("/buy_goods")
    public String buy_Goods() {

        String value = UUID.randomUUID()+Thread.currentThread().getName(); // 唯一固定标识

        try {
            // ⚠️ redis天生就是单线程的
            Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK, value);// 相当于setNX(set key if it doesn't exist)

            if (!flag){
                System.out.println("抢锁失败");
                return "抢锁失败";
            }

            String result = stringRedisTemplate.opsForValue().get("goods:001");// get key === 看看库存数量够不够
            int goodsNumber = result == null ? 0 : Integer.parseInt(result);

            if (goodsNumber > 0) {
                int realNumber = goodsNumber - 1;
                stringRedisTemplate.opsForValue().set("goods:001", String.valueOf(realNumber));
                System.out.println("成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort);
                return "成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort;
            } else {
                System.out.println("商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort);
                return "商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort;
            }
        } finally {
            stringRedisTemplate.delete(REDIS_LOCK); // 解锁
        }

    }
}
```

## 3.宕机了

**问题：**

部署了微服务jar包的机器挂了，代码层面根本没有走到finally这块， 没办法保证解锁，这个key没有被删除，**需要加入一个过期时间限定key。**



**解决方案：**

需要对lockKey有过期时间的设定

```java
Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK, value);// 相当于setNX
stringRedisTemplate.expire(REDIS_LOCK,10L,TimeUnit.SECONDS); // 设置过期时间 防止宕机等原因造成的死锁
```



## 4.没有考虑原子性

**问题：**

设置key+过期时间分开了，必须要合并成一行具备原子性。

**解决方案：**

```java
Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK, value,10L,TimeUnit.SECONDS);
```



## 5.可能会删除了别人的锁

**问题：**张冠李戴，删除了别人的锁

![image-20210112123053928](/assets/imgs/image-20210112123053928.png)

**解决方案：**

只能自己删除自己的，不许动别人的。

加一层判断：

```java
@RestController
public class GoodController {

    public static final String REDIS_LOCK = "silince";

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Value("${server.port}")
    private String serverPort;

    private ReentrantLock lock = new ReentrantLock();

    @GetMapping("/buy_goods")
    public String buy_Goods() {

        String value = UUID.randomUUID()+Thread.currentThread().getName(); // 唯一固定标识

        try {
            Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK, value,10L,TimeUnit.SECONDS);

            if (!flag){
                System.out.println("抢锁失败");
                return "抢锁失败";
            }

            String result = stringRedisTemplate.opsForValue().get("goods:001");// get key === 看看库存数量够不够
            int goodsNumber = result == null ? 0 : Integer.parseInt(result);

            if (goodsNumber > 0) {
                int realNumber = goodsNumber - 1;
                stringRedisTemplate.opsForValue().set("goods:001", String.valueOf(realNumber));
                System.out.println("成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort);
                return "成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort;
            } else {
                System.out.println("商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort);
                return "商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort;
            }
        } finally {
            // ⚠️ 判断删除的是否是自己的锁
            if (stringRedisTemplate.opsForValue().get(REDIS_LOCK).equalsIgnoreCase(value)){
                stringRedisTemplate.delete(REDIS_LOCK);
            }
        }
    }
}
```



## 6.finally块的判断+del删除操作不是原子性的

**问题：**

finally块的判断+del删除操作不是原子性的。

```java
// 判断加锁于解锁是不是同一个客户端
if (stringRedisTemplate.opsForValue().get(REDIS_LOCK).equalsIgnoreCase(value)){
  // 若在此时，这把锁突然不是这个客户端的，则会误解锁（判断完后，刚好时间到了导致锁自动被释放，别的线程抢占了该锁）
  stringRedisTemplate.delete(REDIS_LOCK);
}
```

**解决方式：**

1）方式一：用redis自身的事务

事务介绍：

- Redis的事务是通过**MULTI， EXEC， DISCARD和WATCH**这四个命令来完成。
- Redis的单个命令都是**原子性**的，所以这里确保事务性的对象是**命令集合**。
- Redis将命令集合序列化并确保处于一事务的**命令集合连续且不被打断**的执行。
- Redis**不支持回滚**的操作。

相关命令：

- MULTI
  - 用于标记事务块的开始，Redis会将后续的命令逐个放入队列中，然后使用**EXEC命令**原子化地执行这个命令序列。
- EXEC
  - 在一个**事务中执行所有先前放入队列的命令**，然后恢复正常的连接状态。
- DISCARD
  - 清楚所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。
- WATCH
  - 当某个**事务需要按条件执行**时，就要使用这个命令将给定的**键设置为受监控的状态。**
  - 语法：WATCH key [key ....]
  - 该命令可以实现 redis 的**乐观锁**

- UNWATCH
  - 清除所有先前为一个事务监控的键

```java
finally {
  while (true){
    stringRedisTemplate.watch(REDIS_LOCK);
    if (stringRedisTemplate.opsForValue().get(REDIS_LOCK).equalsIgnoreCase(value)){
      stringRedisTemplate.setEnableTransactionSupport(true); // 开启事务支持
      stringRedisTemplate.multi();
      stringRedisTemplate.delete(REDIS_LOCK);
      List<Object> list = stringRedisTemplate.exec();
      if (list != null){ // list==null 表示删除成功;否则继续尝试删除
        continue;
      }
    }
    stringRedisTemplate.unwatch();
    break;
  }
```



2）方式二：[用Lua脚本](https://redis.io/commands/set) 推荐

```java
@RestController
public class GoodController {

    public static final String REDIS_LOCK = "silince";

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Value("${server.port}")
    private String serverPort;

    private ReentrantLock lock = new ReentrantLock();

    @GetMapping("/buy_goods")
    public String buy_Goods() throws Exception {

        String value = UUID.randomUUID()+Thread.currentThread().getName(); // 唯一固定标识

        try {
            Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK, value,10L,TimeUnit.SECONDS);

            if (!flag){
                System.out.println("抢锁失败");
                return "抢锁失败";
            }

            String result = stringRedisTemplate.opsForValue().get("goods:001");// get key === 看看库存数量够不够
            int goodsNumber = result == null ? 0 : Integer.parseInt(result);

            if (goodsNumber > 0) {
                int realNumber = goodsNumber - 1;
                stringRedisTemplate.opsForValue().set("goods:001", String.valueOf(realNumber));
                System.out.println("成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort);
                return "成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort;
            } else {
                System.out.println("商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort);
                return "商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort;
            }
        } finally {
            Jedis jedis = RedisUtils.getJedis();
            
            String script = "if redis.call(\"get\",KEYS[1]) == ARGV[1]\n" +
                    "then\n" +
                    "    return redis.call(\"del\",KEYS[1])\n" +
                    "else\n" +
                    "    return 0\n" +
                    "end";
            try{
                // 成功返回1，失败返回0。
                Object o = jedis.eval(script, Collections.singletonList(REDIS_LOCK), Collections.singletonList(value));
                if ("1".equals(o.toString())){
                    System.out.println("-----del redis lock ok");
                }else {
                    System.out.println("-----del redis lock error");
                }
            }finally {
                if (jedis!=null){
                    jedis.close();
                }
            }
            
        }

    }
}
```

- 工具类 RedisUtils.java

```java
public class RedisUtils {
    private static JedisPool jedisPool;

    static {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(20);
        jedisPoolConfig.setMaxIdle(10);
        jedisPool=new JedisPool(jedisPoolConfig,"127.0.0.1",6379);
    }

    public static Jedis getJedis() throws Exception{
        if (jedisPool!=null){
            return jedisPool.getResource();
        }
        throw new Exception("Jedispoll is not ok");
    }
}
```

## 7.确保redisLock过期时间大于业务执行时间的问题

**问题：**

1. Redis 分布式锁如何续期？

2. 集群存在的问题+CAP，对比zookeeper：

![image-20210112134017876](/assets/imgs/image-20210112134017876.png)

- Redis 侧重 AP
  - **redis异步复制造成的锁丢失，** 比如:主节点没来的及把刚刚set进来这条数据给从节点，就挂了。
  - **此时如果集群模式下，就得上Redisson来解决**
- Zookeeper 侧重 CP（保证一致性）



## 8.终极版 Redisson

redis集群环境下，我们自己写的也不OK, 直接上RedLock之[Redisson](https://github.com/redisson/redisson)落地实现。

- RedisConfig.java

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Serializable> redisTemplate(LettuceConnectionFactory connectionFactory){
        RedisTemplate<String, Serializable> redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(connectionFactory);

        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        return redisTemplate;
    }
    
    @Bean
    public Redisson redisson(){
        Config config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379").setDatabase(0);
        
        return (Redisson) Redisson.create(config);
    }

}
```

- GoodController.java

```java
@RestController
public class GoodController {

    public static final String REDIS_LOCK = "silince";

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Value("${server.port}")
    private String serverPort;

    @Autowired
    private Redisson redisson;

    @GetMapping("/buy_goods")
    public String buy_Goods() throws Exception {

        String value = UUID.randomUUID() + Thread.currentThread().getName(); // 唯一固定标识

        RLock redissonLock = redisson.getLock(REDIS_LOCK);
        redissonLock.lock();
        try {
            String result = stringRedisTemplate.opsForValue().get("goods:001");// get key === 看看库存数量够不够
            int goodsNumber = result == null ? 0 : Integer.parseInt(result);

            if (goodsNumber > 0) {
                int realNumber = goodsNumber - 1;
                stringRedisTemplate.opsForValue().set("goods:001", String.valueOf(realNumber));
                System.out.println("成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort);
                return "成功买到商品，库存还剩下：" + realNumber + " 件" + "\t 服务提供端口" + serverPort;
            } else {
                System.out.println("商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort);
                return "商品已经售完/活动结束/调用超时" + "\t 服务提供端口" + serverPort;
            }
        } finally {
            redissonLock.unlock();
        }

    }
}
```



## 9.Redis9.0版bug及完善到9.1

出现这个错误的原因：是在并发多的时候就可能会遇到这种错误，可能会被重新抢占

![image-20210112200709999](/Users/silince/Pictures/Typora/image-20210112200709999.png)

不见得当前这个锁的状态还是在锁定，并且本线程持有，最好再加一层判断：

```java
finally {
  if (redissonLock.isLocked() && redissonLock.isHeldByCurrentThread()){
    redissonLock.unlock();
  }
}
```



# 总结

- synchronized   单机版ok，上分布式
- nginx分布式微服务 单机锁不行
- 取消单机锁     上redis分布式锁setnx
- 只加了锁，没有释放锁， 出异常的话，可能无法释放锁， 必须要在代码层面finally释放锁
- 宕机了，部署了微服务代码层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要有lockKey的过期时间设定
- 为redis的分布式锁key，增加过期时间，此外，还必须要setnx+过期时间必须同一行的原子性操作
- 必须规定只能自己删除自己的锁，你不能把别人的锁删除了,防止张冠李戴，1删2,2删3
- lua或者事务
- redis集群环境下，我们自己写的也不OK。直接上RedLock之Redisson落地实现