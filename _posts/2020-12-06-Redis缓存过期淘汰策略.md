---
layout: post
title: "Redis缓存过期淘汰策略"
date: 2020-12-06 21:41:16 +0800--
categories: [Java, 数据库]
tags: [Java, 分布式, redis,]  

---

# 常见的面试题

- 生厂上你们的redis内存设置多少
- 如何配置、修改redis的内存大小
- 如果内存满了你怎么办
- redis清理内存的方式？定期删除和惰性删除了解过吗？
- redis缓存淘汰策略
- redis的LRU了解过吗？可否手写一个LRU算法



# Redis内存满了怎么办

## Redis内存配置

1）查看Redis最大占用内存

打开redis配置文件，设置maxmemory参数，**maxmemory是bytes字节类型，注意转换。**

![image-20210113161207026](/assets/imgs/image-20210113161207026.png)

2）redis默认内存多少可以用？

如果不设置最大内存或者设置最大内存大小为0，**在64位操作系统下不限制内存大小**，在32位操作系统下最多使用3GB内存。

3）一般生产上如何配置？

一般推荐Redis设置内存为最大物理内存的四分之三，也就是0.75。

4）如何修改redis内存设置

- 通过修改文件配置 `maxmemory 104857600`
- 通过命令修改 `config set maxmemory 104857600`

5）什么命令查看redis内存使用情况?

```shell
info memory
```



## Redis内存使用超出了设置值会发生什么

改改配置，故意把最大值设为1个byte试试。

```shell
出现以下报错： (error) OOM command not allowed when used memory > 'maxmemory'
```

结论：

设置了maxmemory的选项，假如redis内存使用达到上限，没有加上过期时间就会导致数据写满maxmemory 为了避免类似情况，引出下一章内存淘汰策略。

---

# Redis缓存淘汰策略

## 写的数据是怎么消失的

### 过期键的删除策略

如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢?

不是，那过期后到底什么时候被删除的？是个什么操作?

### 三种不同的删除策略

#### 定时删除

> 对CPU不友好，用处理器性能换取存储空间（拿时间换空间）

Redis不可能时时刻刻遍历所有被设置了生存时间的key，来检测数据是否已经到达过期时间，然后对它进行删除。

立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力，让CPU心累，时时需要删除，忙不过来啦😠。

**这会产生大量的性能消耗，同时也会影响数据的读取操作。**



#### 惰性删除

> 对memory不友好，用存储空间换取处理器性能（拿空间换时间)

数据到达过期时间，不做处理。等下次访问该数据时：

- 如果未过期，返回数据；

- 发现已过期，删除，返回不存在。

**惰性删除策略的缺点是，它对内存是最不友好的。**

如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。

**在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除(除非用户手动执行FLUSHDB)**，我们甚至可以将这种情况看作是一种内存泄漏，无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说,肯定不是一个好消息。



#### 折中方案：定期删除

> 定期抽样key，判断是否过期。存在漏网之🐟

**定期删除策略是前两种策略的折中:**

定期删除策略**每隔一段时间执行一次删除过期键操作**，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度特点：

1. CPU性能占用设置有峰值，检测频度可自定义设置特点
2. 内存压力不是很大，长期占用内存的冷数据会被持续清理

举例：

redis默认每个100ms检查，是否有过期的key，有过期key则删除。⚠️注意：redis不是每隔100ms将所有的key检查一次而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis直接进去ICU)。**因此，如果只采用定期删除策略，会导致很多key到时间没有删除（存在漏网之🐟）**。

定期删除策略的难点是确定删除操作执行的时长和频率：如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的**执行时长和执行频率。**



## 缓存淘汰策略

### 上述删除策略存在的问题

1. 定期删除时，从来没有被抽查到
2. 惰性删除时，也从来没有被点中使用过

从而导致**大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽**。必须要有一个更好的兜底方案。



### 缓存淘汰策略种类

- noeviction: 不会驱逐任何key  😎**出厂默认**
- allkeys-lru: 对所有key使用LRU算法进行删除  😎 **最通用的方案**
- volatile-lru: 对所有设置了过期时间的key使用LRU算法进行删除
- allkeys-random: 对所有key随机删除
- volatile-random: 对所有设置了过期时间的key随机删除
- volatile-ttl: 删除马上要过期的key
- allkeys-lfu: 对所有key使用LFU算法进行删除
- volatile-lfu: 对所有设置了过期时间的key使用LFU算法进行删除



### 总结

一共有`2(维度)*4(方面)=8`种方案：

2个维度：

- 过期键种筛选
- 所有键中筛选

4个方面：

- LRU
- LFU
- random
- ttl





## 如何配置和修改

- 命令方式 `config set maxmemory-policy allkeys-lru`
- 配置文件中添加  `maxmemory-policy allkeys-lru`



# Redis的LRU算法简介

[LRU](https://leetcode-cn.com/problems/lru-cache/)是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的数据予以淘汰。

设计思想:

1. 所谓缓存，必须要有读+写两个操作，按照命中率的思路考虑，写操作+读操作时间复杂度都需要为O(1) 

2. 特性要求分析

- 必须有顺序之分，以区分最近使用的和很久没用到的数据排序。
- 写和读操作一次搞定。
- 如果容量(坑位)满了要删除最不长用的数据，每次新访问还要把新的数据插入到队头(按照业务你自己设定左右那一边是队头) 

​     **查找快，插入快，删除快，且还需要先后排序-------->什么样的数据结构满足这个问题?**

你是否可以在O(1)时间复杂度内完成这两种操作?如果一次就可以找到，你觉得什么数据结构最合适?

- LRU的算法核心是哈希链表，本质就是HashMap+DoubleLinkedList 时间复杂度是O(1)，哈希表+双向链表的结合体。
- 或者直接使用JDK中的 LinkedHashMap 类。

![image-20210113202318540](/assets/imgs/image-20210113202318540.png)



