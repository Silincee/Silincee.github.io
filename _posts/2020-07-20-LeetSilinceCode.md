---
layout: post
title:  "LeetSilinceCode"
date:   2020-07-20 13:20:06 +0800--
categories: [数据结构]
tags: [LeetCode,数据结构 ]  


---

# PLAN

> leetcode: https://leetcode-cn.com/tag/array/
>
> 刷题模版： https://greyireland.gitbook.io/algorithm-pattern/	
>
> repo：https://github.com/labuladong/fucking-algorithm

```
我的方法只适合连数据结构都不扎实的菜鸡选手～不要完全按tag！头一次刷，先把这五个tag做了：array，string，tree，linkedlist，math，其它的千万别按tag刷。这样不存在前面答案说的思维暗示问题，反而帮助巩固数据结构，还可以自己归纳某种数据结构的全部技巧～ 每个tag内部就按照easy-medium-hard的顺序做，这样最开始一天刷10道easy，后面熟了这个数据结构一天也能刷5道难题，不会一开始就卡壳，搞得自己很郁闷。这时候已经100多道了，之后从hard往easy刷！前面虐虐虐，后面一天20道easy爽歪歪，很快就刷完啦！赶快买个会员开始第二遍吧！
```

## **刷题策略**： 

**时间紧迫**：

- 刷题目录：https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md
- 在 [https://leetcode-cn.com/problemset/all/](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problemset/all/) 页面的右侧。先刷热题 HOT 100，再刷精选 TOP 面试题，之后刷其他的题。

- https://zhuanlan.zhihu.com/p/96883783
- https://www.byteflying.com/archives/1015
- [IDEA配置leetcode插件](https://blog.csdn.net/u010180815/article/details/104728115/)



# 算法思想

## 双指针

| 题目                                                         | 算法思想 | 正确率 |
| ------------------------------------------------------------ | -------- | ------ |
| [\#167 有序数组的 Two Sum](http://www.silince.cn/2020/07/20/LeetSilinceCode/#167-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84-two-sum) | 双指针   | 0%     |
| [\#633 两数平方和](http://www.silince.cn/2020/07/20/LeetSilinceCode/#633-%E4%B8%A4%E6%95%B0%E5%B9%B3%E6%96%B9%E5%92%8C) | 双指针   | 0%     |
| [\#345 反转字符串中的元音字符](http://www.silince.cn/2020/07/20/LeetSilinceCode/#345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6) | 双指针   | 0%     |
| [\#680 回文字符串](http://www.silince.cn/2020/07/20/LeetSilinceCode/#680-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2) | 双指针   | 0%     |
| [\#88 合并两个有序数组](http://www.silince.cn/2020/07/20/LeetSilinceCode/#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84) | 双指针   | 0%     |
| [\#141 判断链表是否存在环]([http://www.silince.cn/2020/07/20/LeetSilinceCode/#141-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%8E%AF](http://www.silince.cn/2020/07/20/LeetSilinceCode/#141-判断链表是否存在环)) | 双指针   | 0%     |
| [\#542 最长子序列]([http://www.silince.cn/2020/07/20/LeetSilinceCode/#542-%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97](http://www.silince.cn/2020/07/20/LeetSilinceCode/#542-最长子序列)) | 双指针   | 0%     |



## 排序算法

![image-20200720125956366](/assets/imgs/image-20200720125956366-9188642.png)

[十大排序算法](https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg)

[排序算法的复杂度、实现和稳定性](https://www.jianshu.com/p/916b15eae350)

## 贪心思想

## 二分查找

## 分治

## 搜索

## 动态规划

## 数学







# 数据结构相关

正确率 > 80% 可移除 👩🏻‍💻

## Array

> https://leetcode-cn.com/tag/array/

| 题目                                                         | 算法思想                  | 正确率 |
| ------------------------------------------------------------ | ------------------------- | ------ |
| [\#26 删除排序数组中的重复项](http://www.silince.cn/2020/07/20/LeetSilinceCode/#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9) | 双指针                    | 0%     |
| [\#88 合并两个有序数组](http://www.silince.cn/2020/07/20/LeetSilinceCode/#88-合并两个有序数组) | 双指针                    | 0%     |
| [\#169 多数元素](http://www.silince.cn/2020/07/20/LeetSilinceCode/#169-多数元素) | 哈希表/排序/随机化/投票法 | 0%     |
| [\#674 最长连续递增序列](http://www.silince.cn/2020/07/20/LeetSilinceCode/#674-最长连续递增序列) | 动态规划                  | 0%     |
| [\#1051 高度检查器](http://www.silince.cn/2020/07/20/LeetSilinceCode/#1051-高度检查器) | 桶排序                    | 50%    |
| [\#1160 拼写单词](http://www.silince.cn/2020/07/20/LeetSilinceCode/#1160-拼写单词) | counter方法/HashMap       | 0%     |



## String

## Tree

## HashTable

## Graph



# 题：

## [#26 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/) 

- Easy
- 2019.08.30：😭 

题目：

```xml
给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
```

分析：双指针法

```xml
数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。慢指针 i 用于记录最后一次出现的数字，快指针 j 用于遍历数组的每一个元素，并把未出现过的数赋值给第 i+1 个元素。

只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j] 不等于 nums[i]，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。

复杂度分析
时间复杂度：O(n)O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。
空间复杂度：O(1)O(1)。
```

代码：

```java
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.length; j++) {
        if (nums[j] != nums[i]) {
            nums[++i]=nums[j];
        }
    }
    return i + 1;
}
```

---





## [#88 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/) 

- Easy
- 2019.08.30：😭 

题目：

```xml
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 
```

分析：双指针

```xml
方法一 : 合并后排序
直觉
最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(Java是2行)，时间复杂度较差，为O((n + m)log(n + m)。这是由于这种方法没有利用两个数组本身已经有序这一点。
复杂度分析:
时间复杂度 : O((n+m)log(n+m))
空间复杂度 : O(1)

方法二 : 双指针 / 从前往后
一般而言，对于有序数组可以通过 双指针法达到O(n + m)的时间复杂度。
最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。
由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m) 的空间复杂度。
复杂度分析:
时间复杂度 : O(n+m)
空间复杂度 : O(m)

⭐️方法三 : 双指针 / 从后往前
方法二已经取得了最优的时间复杂度O(n + m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置。
如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。
这里的指针 p 用于追踪添加元素的位置。
复杂度分析:
时间复杂度 : O(n + m)
空间复杂度 : O(1)
```

代码：

```java
// 方法一
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    System.arraycopy(nums2, 0, nums1, m, n);
    Arrays.sort(nums1);
  }
}

// 方法二
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // 由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方.
    int [] nums1_copy = new int[m];
    System.arraycopy(nums1, 0, nums1_copy, 0, m);

    //  设置 nums1_copy 和 nums2 的指针
    int p1 = 0;
    int p2 = 0;

    // 设置 nums1 的指针
    int p = 0;

    // 比较 nums1_copy 和 nums2 中的元素，并把小的元素放入 nums1
    while ((p1 < m) && (p2 < n))
      nums1[p++] = (nums1_copy[p1] < nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];
    // 如果还有元素未被放入 nums1
    if (p1 < m)
      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);
    if (p2 < n)
      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);
  }
}

// ⭐️方法三
class Solution {
  public void merge(int[] nums1, int m, int[] nums2, int n) {
    // 设置 nums1 和 nums2 的指针
    int p1 = m - 1;
    int p2 = n - 1;
    // 设置 合并后nums1 的指针
    int p = m + n - 1;

    // 比较 nums1 和 nums2 中的元素，并把大的元素放入 nums1 [从尾部放入]
    while ((p1 >= 0) && (p2 >= 0))
      nums1[p--] = (nums1[p1] < nums2[p2]) ? nums2[p2--] : nums1[p1--];

    // 如果 nums2 还有剩余，全部放入 nums1 的顶端 (如果剩余的是nums1则p2=-1,等于无变化)
    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);
  }
}
```

---

## [\#141 判断链表是否存在环](https://leetcode-cn.com/problems/linked-list-cycle/description/)





## [\#167 有序数组的 Two Sum](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/)



## [#169 多数元素](https://leetcode-cn.com/problems/majority-element/) 

- Easy
- 2019.08.30：😭 哈希表，naive！ 

题目：

```xml
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1:
输入: [3,2,3]
输出: 3

示例 2:
输入: [2,2,1,1,1,2,2]
输出: 2
```

分析：

```xml
方法一：哈希表
思路：
遍历整个数组，对记录每个数值出现的次数(利用HashMap，其中key为数值，value为出现次数)；
接着遍历HashMap中的每个Entry，寻找value值> nums.length/2 的key即可。
复杂度分析：
时间复杂度：O(n)。
空间复杂度：O(n)。哈希表最多包含 n - [n/2] 个键值对，所以占用的空间为 O(n)。

方法二：排序
思路：
如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 [n/2] 的元素（下标从 0 开始）一定是众数。
算法：
对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 n 为奇数的情况，第二个例子是 n 为偶数的情况。
对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 [n/2] 的地方有重叠。因此，无论众数是多少，返回 [n/2]下标对应的值都是正确的。
复杂度分析：
时间复杂度：O(nlogn)。将数组排序的时间复杂度为 O(nlogn)。
空间复杂度：O(logn)。如果使用语言自带的排序算法，需要使用 O(logn) 的栈空间。如果自己编写堆排序，则只需要使用 O(1) 的额外空间。

方法三：随机化
思路：
因为超过 [n/2]的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。
算法：
由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。
复杂度分析
时间复杂度：理论上最坏情况下的时间复杂度为 O(∞)，因为如果我们的语气很差，这个算法会一直找不到众数，随机挑选无穷多次，所以最坏时间复杂度是没有上限的。每一次随机后，我们需要 O(n)O(n) 的时间判断这个数是否为众数，因此期望的时间复杂度为 O(n)。
空间复杂度：O(1)。随机方法只需要常数级别的额外空间。

方法四：摩尔投票法
候选人(cand_num)初始化为nums[0]，票数count初始化为1。
当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。
当票数count为0时，更换候选人，并将票数count重置为1。
遍历完数组后，cand_num即为最终答案。

为何这行得通呢？
投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。
且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。
因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。
这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。
无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。
```

方法二说明：

![image-20200831201456212](/assets/imgs/image-20200831201456212-9188642.png)

代码：

```java
// 方法一：哈希表计数法
class Solution {
    public int majorityElement(int[] nums) {
        Map<Integer, Long> map = Arrays.stream(nums).boxed().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        long limit = nums.length >> 1;
        for (Map.Entry<Integer, Long> entry : map.entrySet())
            if (entry.getValue() > limit)
                return entry.getKey();
        return -1;
    }
}

// 方法二: 排序
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}

// 方法三：随机化
class Solution {
    private int randRange(Random rand, int min, int max) {
        return rand.nextInt(max - min) + min;
    }

    private int countOccurences(int[] nums, int num) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == num) {
                count++;
            }
        }
        return count;
    }

    public int majorityElement(int[] nums) {
        Random rand = new Random();

        int majorityCount = nums.length/2;

        while (true) {
            int candidate = nums[randRange(rand, 0, nums.length)];
            if (countOccurences(nums, candidate) > majorityCount) {
                return candidate;
            }
        }
    }
}

// 方法四：摩尔投票法
class Solution {
    public int majorityElement(int[] nums) {
        int cand_num = nums[0], count = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (cand_num == nums[i])
                ++count;
            else if (--count == 0) {
                cand_num = nums[i];
                count = 1;
            }
        }
        return cand_num;
    }
}
```





---

## [\#345 反转字符串中的元音字符](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/)



## [\#542 最长子序列](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/)



## [\#633 两数平方和](https://leetcode-cn.com/problems/sum-of-square-numbers/description/)



## [#674 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)  

- Easy
- 2019.08.30：😭 

题目：

```xml
给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。

示例 1:
输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。

注意：数组长度不会超过10000。
```

分析：动态规划

```xml
算法：
每个（连续）增加的子序列是不相交的，并且每当 nums[i-1]>=nums[i] 时，每个此类子序列的边界都会出现。当它这样做时，它标志着在 nums[i] 处开始一个新的递增子序列，我们将这样的 i 存储在变量 anchor 中。
例如，如果 nums=[7，8，9，1，2，3]，那么 anchor 从 0 开始（nums[anchor]=7），并再次设置为 anchor=3（nums[anchor]=1）。无论 anchor 的值如何，我们都会记录 i-anchor+1 的候选答案、子数组 nums[anchor]、nums[anchor+1]、…、nums[i] 的长度，并且我们的答案会得到适当的更新。

复杂度分析：
时间复杂度：O(N)O(N)，其中 NN 是 nums 的长度。我们通过 nums 执行一个循环。
空间复杂度：O(1)O(1)，anchor 和 ans 使用了常数级空间。
```

代码：

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        // nums[anchor] 处开始一个新的递增子序列
        // ans 当前子序列长度
        int ans = 0, anchor = 0;
        for (int i = 0; i < nums.length; i++) {
            // i=0时候，i>0为false就不会继续操作&&后的代码了
            if (i > 0 && nums[i-1] >= nums[i]) anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
    }
}
```

---

## [\#680 回文字符串](https://leetcode-cn.com/problems/valid-palindrome-ii/description/)



## [#1051 高度检查器](https://leetcode-cn.com/problems/height-checker/)  

- Easy
- 2019.08.28：😭  在对比一次后，忘记加arr[j]--；
- 2019.08.29：😎

题目：

```xml
学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。
请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。
注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。
提示：1 <= heights.length <= 100
		 1 <= heights[i] <= 100
```

分析：桶排序

```xml
非递减 排序也就是升序排列，最直观的一种解法就是排序后对比计数每个位置的不同数量。
但是涉及到比较排序，时间复杂度最低也有 O(NlogN)O(NlogN)。

我们真的需要排序吗？
首先我们其实并不关心排序后得到的结果，我们想知道的只是在该位置上，与最小的值是否一致
题目中已经明确了值的范围 1 <= heights[i] <= 100
这是一个在固定范围内的输入，比如输入： [1,1,4,2,1,3]
输入中有 3 个 1,1 个 2，1 个 3 和 1 个 4，  3 个 1 肯定会在前面，依次类推
所以，我们需要的仅仅只是计数而已
```

代码：

```java
public int heightChecker(int[] heights) {
  			//1 设置100个桶，用于放入身高
        // 值的范围是1 <= heights[i] <= 100，因此需要1,2,3,...,99,100，共101个桶,0号桶不用
        int[] arr = new int[101];
        // 遍历数组heights，计算每个桶中有多少个元素，也就是数组heights中有多少个1，多少个2，...
        for (int i = 0; i < heights.length; i++) {
            arr[heights[i]]++;
        }

        //2 排序按桶的顺序依次取出(将这101个桶中的元素顺序桶地取出来，元素就是有序的)，与原数组做对比
        int j = 1;
        int count = 0;
        // 每个height必须比到一个非0值
        for (int height : heights) {
            while (arr[j] <= 0) {
                j++;
            }
            if (height != j) count++;
          	// 2019.08.28：😭 匹配到非0值后需要移除一个桶元素
            arr[j]--;
        }
        return count;
    }
```

---

## [#1160 拼写单词](https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/) 

- Easy
- 2019.08.30：😭 

题目：

```xml
给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。
假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。
注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。
返回词汇表 words 中你掌握的所有单词的 长度之和。

示例 1：
输入：words = ["cat","bt","hat","tree"], chars = "atach"
输出：6
解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。
```

分析：

```xml
这是一类经典的题型。凡是和“变位词”、“字母顺序打乱”相关的题目，都考虑统计字母出现的次数。这种方法我叫做 “counter 方法”。
我们既统计“字母表”中字母出现的次数，也统计单词中字母出现的次数。如果单词中每种字母出现的次数都小于等于字母表中字母出现的次数，那么这个单词就可以由字母表拼出来。
如何实现计数结构呢？一般的方法是用 Java 的 HashMap。但是我们注意到题目有一个额外的条件：所有字符串中都仅包含小写英文字母。这意味着我们可以用一个长度为 26 的数组来进行计数。
```

![5cda24dc2d60dba242e50c7c9c2e008e3856d19d28ec14b6ed48292aaf0ee526](/assets/imgs/5cda24dc2d60dba242e50c7c9c2e008e3856d19d28ec14b6ed48292aaf0ee526.gif)

代码：

```java
public int countCharacters(String[] words, String chars) {
    int[] chars_count = count(chars); // 统计字母表的字母出现次数
    int res = 0; // 所有可用单词长度之和
    for (String word : words) {
        int[] word_count = count(word); // 统计单词的字母出现次数
        if (contains(chars_count, word_count)) {
            res += word.length();
        }
    }
    return res;
}

// 检查字母表的字母出现次数是否覆盖单词的字母出现次数
boolean contains(int[] chars_count, int[] word_count) {
    for (int i = 0; i < 26; i++) {
        if (chars_count[i] < word_count[i]) {
            return false;
        }
    }
    return true;
}

// 统计 26 个字母出现的次数,用一个26位的数组表示
int[] count(String word) {
    int[] counter = new int[26];
    for (int i = 0; i < word.length(); i++) {
        char c = word.charAt(i);
        counter[c-'a']++;
    }
    return counter;
}
```



# 模版.

### 题号 

- 难度
- 2019.08.28：😭  

题目：

```xml

```

分析：

```xml

```

代码：

```java

```

