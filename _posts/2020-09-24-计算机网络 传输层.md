---
layout: post
title:  "计算机网络 传输层"
date:   2020-09-24 14:58:06 +0800--
categories: [计算机网络]
tags: [计算机网络, ]  

---

# 传输层协议概述

从通信和信息处理的角度看，运输层向 它上面的应用层提供通信服务，它属于 面向通信部分的最高层，同时也是用户 功能中的最低层。

当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。

***运输层为相互通信的应用进程提供了逻辑通信。***

![image-20200924193156923](/assets/imgs/image-20200924193156923.png)

## 应用进程之间的通信

- 两个主机进行通信实际上就是两个主机中的***应用进程互相通信***。
- 应用进程之间的通信又称为***端到端的通信***。
- 运输层的一个很重要的功能就是***复用和分用***。 应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。
- “***运输层提供应用进程间的逻辑通信***”。“逻辑通信”的意思是:运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层 之间并没有一条水平方向的物理连接。



## 运输层的主要功能

- ***运输层为应用进程之间提供端到端的逻辑通信(但网络层是为主机之间提供逻辑通信)。*** 
- 运输层还要对收到的报文进行差错检测。
- 运输层需要有两种不同的运输协议，即面向连 接的 TCP 和无连接的 UDP。



## 两种不同的运输协议

运输层向高层用户屏蔽了下面网络核心的细节 (如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

- 当运输层采用面向连接的 TCP 协议时，***尽管下面的网络是不可靠的(只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工的可靠信道。***
- 当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条***不可靠信道***。





## 传输层和应用层之间的关系

1）运输层的端口

- 运行在计算机中的进程是用***进程标识符***来标志的。
- 运行在应用层的各种应用进程却不应当让计算机操 作系统指派它的进程标识符。这是因为在因特网上使用的计算机的操作系统种类很多，而不同的操作 系统又使用不同格式的进程标识符。
- 为了使运行不同操作系统的计算机的应用进程能够 互相通信，就***必须用统一的方法对 TCP/IP 体系的 应用进程进行标志。***

2）端口号(protocol port number)

- 解决这个问题的方法就是在运输层使用协议端 口号(protocol port number)，或通常简称为端 口(port)。
- 虽然通信的终点是应用进程，但我们可以把***端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口***， 剩下的工作(即最后交付目的进程)就由 TCP 来完成。

3）三类端口与常用端口

- 熟知端口，数值一般为 0 ～1023

- 登记端口号，数值为 1024 ～ 49151

  为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。

- 客户端口号/短暂端口号，数值为 49152 ～ 65535

  留给客户进程选择暂时使用。 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后， 这个端口号可供其他客户进程以后使用。

常用端口：

http = TCP + 80 

https = TCP + 443

ftp = TCP + 21

SMTP = TCP +25

POP3 = TCP + 110

RDP = TCP + 3389

共享文件夹 = TCP + 445

SQL = TCP + 1433

DNS = UDP + 53 or TCP + 53





## 应用层协议和服务之间的关系

服务运行后使用在TCP或UDP的某个端口侦听客户端的请求





# TCP 与 UDP的区别

- 两个对等运输实体在通信时传送的数据单位叫作运***输协议数据单元 TPDU (Transport Protocol Data Unit)***。
- TCP 传送的数据单位协议是 ***TCP 报文段 (segment)***
- UDP传送的数据单位协议是***UDP报文或用户数据报。***
- ***UDP 在传送数据之前不需要先建立连接***。对 方的运输层在收到 UDP 报文后，不需要给出 任何确认。虽然 UDP ***不提供可靠交付***，但在 某些情况下 UDP 是一种最有效的工作方式。
- ***TCP 则提供面向连接的服务***。TCP 不提供广 播或多播服务。由于 TCP 要提供可靠的、面 向连接的运输服务，因此不可避免地增加了许 多的开销。这不仅使协议数据单元的首部增大 很多，还要占用许多的处理机资源。

![image-20200924194540778](/assets/imgs/image-20200924194540778.png)

⚠️还要强调两点：

- 运输层的 UDP用户数据报与网际层的IP数据报有很大区别。***IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的***。
- TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。***但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。***



## 应用场景

TCP：分段 编号 流量控制 建立会话 `netstat -n`

UDP：不编号(一个数据包即可完成数据通信)  不建立会话  多播 



# UDP协议

## 概述

UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即***端口的功能和差错检测的功能。***

虽然UDP用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。

1）主要特点

- UDP 是无连接的，即发送数据之前不需要建立连接。
- UDP 使用尽最大努力交付，即不保证 可靠交付，同时也不使用拥塞控制。
- UDP 是面向报文的。UDP 没有拥塞控 制，很适合多媒体通信的要求。
- UDP 支持一对一、一对多、多对一和 多对多的交互通信。
- UDP 的首部开销小，只有 8 个字节。

2）UDP 是面向报文的

- 发送方 UDP 对应用程序交下来的报文，在添 加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留 这些报文的边界。
- 应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。
- 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。 
- 应用程序必须选择合适大小的报文。

![image-20200925131229851](/assets/imgs/image-20200925131229851.png)





## UDP的首部格式

UDP 基于端口的分用:

![image-20200925131344508](/assets/imgs/image-20200925131344508.png)

数据报格式：

![image-20200925131313415](/assets/imgs/image-20200925131313415-1010911.png)



- 用户数据报 UDP 有两个字段:***数据字段和首部字段***。首部字段有 8 个字节， 由 4 个字段组成，每个字段都是两个字节。

- 在计算检验和时，***临时把“伪首部”和 UDP 用户数据报连接在一起***。***伪首部仅仅是为了计算检验和***。

- 计算 UDP 检验和的例子

  ![image-20200925131815338](/assets/imgs/image-20200925131815338.png)

# TCP协议

## 概述

### 主要特点

- TCP 是***面向连接***的运输层协议。

- ***每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点 对点的(一对一)。***

- TCP 提供*可靠交付的服务。* 

- TCP提供***全双工通信。***

- ***面向字节流。***

  ![image-20200925132645085](/assets/imgs/image-20200925132645085.png)

### 注意事项 🤔

- TCP 连接是一条虚连接而不是一条真正的物理连接。
- TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。
- TCP ***根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的)。***
- ***TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。***



## TCP的连接

- TCP 把连接作为最基本的抽象。
- 每一条 TCP 连接有两个端点。
- TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做***套接字(socket)或插口***。 
- ***端口号拼接到(contatenated with) IP 地址即构成了套接字。***



## 套接字 (socket)

$$
套接字 socket = (IP地址: 端口号)
$$

每一条 **TCP** 连接唯一地被通信两端的两个 端点(即两个套接字)所确定。即:
$$
TCP 连接 ::= {socket1, socket2}
= {(IP_1: port1), (IP_2: port2)}
$$


***同一个名词 socket 有多种不同的意思:***

1. 应用编程接口 API 称为 socket API, 简称为 socket。
2. socket API 中使用的一个函数名也叫作 socket。
3. 调用 socket 函数的端点称为 socket。
4. 调用 socket 函数时其返回值称为 socket 描述符， 可简称为 socket。
5. 在操作系统内核中连网协议的 Berkeley 实现，称 为 socket 实现。



## TCP报文段的首部格式 🤔

![image-20200925154822204](/assets/imgs/image-20200925154822204.png)



- 源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。***运输层的复用和分用功能都要通过端口才能实现。***

- 序号字段——占 4 字节。***TCP 连接中传送的数据流中的每一个字节都编上一个序号***。序号字段的值则指的是***本报文段所发送的数据的第一个字节的序号。***

- 确认号字段——占 4 字节，***是期望收到对方的下一个报文段的数据的第一个字节的序号***。

- ***数据偏移(即首部长度)***——占 4 位，它***指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。***“数据偏移”的单位是 32 位字(以 4 字节为计算单位)，所以***报文最长为60字节。***

- 保留字段——占 6 位，***保留为今后使用，但目前应置为 0。***

- 抓包分析：

  ![image-20200925183437327](/assets/imgs/image-20200925183437327.png)

- 紧急 URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应***尽快传送(相当于高优先级的数据)***。

- 确认 ACK —— ***只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效***。

- 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，***就尽快地交付接收应用进程***，而不再等到整个缓存都填满了后再向上交付。

- 复位 RST (ReSeT) —— 当 RST = 1 时，***表明 TCP 连接中出现严重差错(如由于主机 崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。***

- 同步 SYN —— ***同步 SYN = 1 表示这是一个连接请求或连接接受报文***，连接建立后置0。

- 终止 FIN (FINis) —— 用来释放一个连接。FIN = 1 ***表明此报文段的发送端的数据已发送完毕***，并要求释放运输连接。

- 窗口字段 —— 占 2 字节，***用来让对方设置发送窗口的依据***，单位为字节。

- 检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。***在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。***

- 紧急指针字段 —— 占 16 位，***指出在本报文段中紧急数据共有多少个字节***(紧急数据放在本报文段数据的最前面)，***只有URG=1时候才生效***。

- ***选项字段 —— 长度可变***。TCP 最初只规定了一种选项，即最大报文段长度 MSS。 MSS 告诉对方 TCP:“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”

- 选项

  - 窗口扩大选项 ——占 3 字节，其中有一个字 节表示移位值 S。新的窗口值等于TCP 首部中 的窗口位数增大到(16 + S)，相当于把窗口值 向左移动 S 位后获得实际的窗口大小。
  - 时间戳选项——占10 字节，其中最主要的字 段时间戳值字段(4 字节)和时间戳回送回答 字段(4 字节)。
  - 选择确认选项(SACK)，会告诉发送端的计算机接受时缺失的序号段

- 填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。





# TCP可靠传输的工作原理

## 停止等待协议

- 在发送完一个分组后，必须***暂时保留已发送的分组的副本***。
- ***分组和确认分组都必须进行编号***。
- 超时计时器的重传时间应当比数据在分组传输的***平均往返时间更长一些。***
- ***停止等待协议的优点是简单，但缺点是信道利用率太低。***

![image-20200925144653291](/assets/imgs/image-20200925144653291.png)



### 确认丢失和确认迟到

***只要你没有告诉我收到了，我就认为你没收到***

![image-20200925144835355](/assets/imgs/image-20200925144835355.png)



### 流水线传输

发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。

由于信道上一直有数据不间断地传送，这种传输 方式可获得很高的信道利用率。

![image-20200925145741645](/assets/imgs/image-20200925145741645.png)

#### 信道利用率

停止等待协议的优点是简单，但缺点是信道利用率太低。
$$
U=T_D/(T_D+RTT+T_A)
$$


![image-20200925145414598](/assets/imgs/image-20200925145414598.png)

#### 连续 ARQ 协议

用于使流水线传输维持可靠传输。只有收到了1的确认才能继续发送6，但是因为每个包都需要确认，效率还不是很高。

![image-20200925150950324](/assets/imgs/image-20200925150950324.png)

#### 累积确认连续 ARQ 协议

- 接收方一般采用***累积确认的方式***。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示:***到这个分组为止的所有分组都已正确收到了***。
- 累积确认有的***优点是:容易实现，即使确认丢失也不必重传***。***缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。***

Go-back-N(回退 N)：

- ***如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前2个分组发出确认。***发送方无法知道后面三个分组的下落，而只好把后面 的三个分组都再重传一次。
- 这就叫做 Go-back-N(回退 N)，表示 需要再退回来重传已发送过的 *N* 个分组。
- ***可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。***



## 可靠通信的实现

- 使用上述的确认和重传机制，我们就可以***在不可靠的传输网络上实现可靠的通信***。
- 这种可靠传输协议常称为***自动重传请求 ARQ (Automatic Repeat reQuest)***。
- ARQ 表明重传的请求是***自动进行***的。接 收方不需要请求发送方重传某个出错的分组。



# TCP可靠传输的实现

TCP 可靠通信的具体实现：

- TCP 连接的***每一端都必须设有两个窗口，一个发送窗口和一个接收窗口。***
- TCP的***可靠传输机制用字节的序号进行控制***。TCP 所有的确认都是基于序号而不是基于报文段。
- TCP两端的***四个窗口经常处于动态变化之中。***
- ***TCP连接的往返时间 RTT 也不是固定不变的。***需要使用特定的算法估算较为合理的重传时间。



## 超时重传时间的选择

- 重传机制是 TCP 中最重要和最复杂的问题之一。

- TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。

- 由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返 时间的方差也很大。

**加权平均往返时间$RTT_S$:**
$$
新的RTT_S = (1 - \alpha)  (旧的RTT_S) + \alpha  (新的 RTT 样本)
$$

- TCP保留了RTT的一个加权平均往返时间$RTT_S$(这又称为平滑的往返时间)。
- 第一次测量到RTT样本时，RTTS值就取为所测量到 的 RTT 样本值。以后每测量到一个新的 RTT 样本， 就按下式重新计算一次 RTTS:
- 式中，0<=a < 1。若a很接近于零，表示RTT值更新 较慢。若选择 a 接近于 1，则表示 RTT 值更新较快。
- RFC2988推荐的a值为1/8，即0.125。

**超时重传时间 RTO (RetransmissionTime-Out):**

- RTO应略大于上面得出的加权平均往返时间$RTT_S$。
- RFC2988建议使用下式计算RTO: $RTO = RTT_S + 4 * RTT_D$



## 选择确认 SACK (Selective ACK)

- 接收方收到了和前面的字节流***不连续的 两个字节块***。
- 如果这些字节的序号都在接收窗口之内， 那么接收方***就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据***。

RFC 2018 的规定:

- 如果要使用选择确认，那么在建立TCP连接时，就要 在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。
- 如果使用选择确认，那么原来首部中的“确认号字段” 的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，***以便报告收到的不连续的字节块的边界***。
- 由于***首部选项的长度最多只有40字节***，而指明一个边界就要用掉 4 字节，因此在***选项中最多只能指明 4 个字节块的边界信息***。【连续字节块的边界(左右边界各*4个字节*)。 指明一个连续字节块要用 8 字节,因此在*选项中最多只能指明 4 个*连续*字节块的边界信息*(共3*4个字节*)。】

![image-20200926144727039](/assets/imgs/image-20200926144727039.png)





## 以字节为单位的滑动窗口技术

> https://www.bilibili.com/video/BV17p411f7ZZ?p=115

1. 根据B给出的窗口值，A构造出自己的发送窗口

   ![image-20200925160854147](/assets/imgs/image-20200925160854147.png)

2. A发送了11个字节的数据

   ![image-20200925160908035](/assets/imgs/image-20200925160908035.png)





3. A 收到新的确认号，发送窗口向前滑动

   ![image-20200925160931992](/assets/imgs/image-20200925160931992.png)



4. A 的发送窗口内的序号都已用完， 但还没有再收到确认，必须停止发送。

   ![image-20200925160949855](/assets/imgs/image-20200925160949855.png)





# TCP实现流量控制

## 利用滑动窗口实现流量控制：

- 一般说来，我们总是希望数据传输得更 快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。
- ***流量控制(flow control)就是让发送方的发 送速率不要太快***，既要让接收方来得及接收，也不要使网络发生拥塞。
- 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。

案例：

![image-20200926160843906](/assets/imgs/image-20200926160843906.png)

## 持续计时器(persistence timer)：

- TCP 为每一个连接设有一个***持续计时器***。
- 只要 TCP 连接的一方收到对方的零窗口通知， 就启动持续计时器。
- 若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅携带 1 字节的数据)，而对方就在确认这个探测报文段时给出了现在的 窗口值。
- 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。
- 若窗口不是零，则死锁的僵局就可以打破了。

## 传输效率问题

- 可以用不同的机制来控制 TCP 报文段的发送时机:
- 第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。
- 第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。
- 第三种机制是发送方的一个计时器期限到了， 这时就把当前已有的缓存数据装入报文段(但长度不能超过 MSS)发送出去。



# TCP的拥塞控制

## 拥塞控制的一般原理

- 在某段时间，若对网络中某资源的需求超过了 该资源所能提供的可用部分，***网络的性能就要变坏——产生拥塞(congestion)。***
- 出现资源拥塞的条件：***对资源需求的总和  > 可用资源***
- 若网络中有许多资源同时产生拥塞，网络的性 能就要明显变坏，整个网络的吞吐量将随输入 负荷的增大而下降。
- 拥塞控制是很难设计的，因为它是一个***动态的(而不是静态的)问题***。
- 当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但***分组的丢失是网络发生拥塞的征兆而不是原因***。
- 在许多情况下，甚至正是***拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因***。 这点应特别引起重视。

## 拥塞控制与流量控制的关系

- ***拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。***
- 拥塞控制是一个全局性的过程，***涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。***
- ***流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。***
- 流量控制所要做的就是***抑制发送端发送数据的速率***，以便使接收端来得及接收。

## 拥塞控制所起的作用

![image-20200926165034243](/assets/imgs/image-20200926165034243.png)

## 开环控制和闭环控制

- 开环控制方法就是在设计网络时***事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞***。
- 闭环控制是基于***反馈环路***的概念。属于闭 环控制的有以下几种措施:
  - 监测网络系统以便检测到拥塞在何时、何处发生。
  - 将拥塞发生的信息传送到可采取行动的地方。 
  - ***调整网络系统的运行以解决出现的问题***。

## 几种拥塞控制方法

### 慢开始和拥塞避免

发送方维持一个叫做***拥塞窗口 cwnd (congestion window)的状态变量***。拥塞窗口的大小取决于网的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。

⭐️发送方控制拥塞窗口的***原则是:只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。***

***但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。***



---

### 慢开始算法的原理

- 在主机刚刚开始发送报文段时可***先设置拥塞窗 口 cwnd = 1，即设置为一个最大报文段 MSS 的数值***。
- 在***每收到一个对新的报文段的确认后，先指数增长到阈值，然后拥塞窗口加 1***，即增加一个 MSS 的数值。
- 用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。

1）传输轮次

- 使用慢开始算法后，***每经过一个传输轮次，拥塞窗口 cwnd 就加倍。***
- 一个传输轮次所经历的时间其实就是往返时间RTT。
- “***传输轮次”更加强调***:把拥塞窗口cwnd所允许发 送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。
- 例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就 是发送方连续发送 4 个报文段，并收到这 4 个报文段 的确认，总共经历的时间。

![image-20200926191424337](/assets/imgs/image-20200926191424337.png)

2）设置慢开始门限状态变量

慢开始门限ssthresh的用法如下:

- ***当 cwnd < ssthresh 时，使用慢开始算法***。
- ***当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。***
- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。
- ***拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大， 即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。***

3）当网络出现拥塞时

- 无论在慢开始阶段还是在拥塞避免阶段，***只要发送方判断网络出现拥塞(其根据就是没有按时收到确认)***，就要把***慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半(但不能小于2)***。
- ***然后把拥塞窗口 cwnd 重新设置为 1，执行慢 开始算法。***
- 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

4）慢开始和拥塞避免算法的实现举例

- 当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节***而使用报文段***。

- ***慢开始门限的初始值设置为 16 个报文段***， 即 ssthresh = 16。
- 发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。***我们假定接收端窗口足够大***，因此现在发送窗口的数值等于拥塞窗口的数值。
- 流程
  - 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M0。
  - 发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M1 和 M2 两个报文段。
  - 接收端共发回两个确认。发送端每收到一个对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。
  - 发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。
  - 当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时(即当 cwnd = 16 时)，***就改为执行拥塞避免算法，拥塞窗口按线性规律增长。***
  - 假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。
  - ***更新后的 ssthresh 值变为 12(即发送窗口数值 24 的一半)***，拥塞窗口再重新设置 为 1，并执行慢开始算法。
  - 当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。

![image-20200926192314229](/assets/imgs/image-20200926192314229.png)

5）小结

乘法减小(multiplicative decrease)：

- “乘法减小“是指不论在慢开始阶段还是拥 塞避免阶段，只要出现一次超时(即出现 一次网络拥塞)，就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。
- 当网络频繁出现拥塞时，ssthresh 值就下 降得很快，以大大减少注入到网络中的分 组数。

加法增大(additive increase)

- “加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 往返时间)，就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止 网络过早出现拥塞。

***必须强调指出：***

-  ***“拥塞避免”并非指完全能够避免了 拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。***
-  ***“拥塞避免”是说在拥塞避免阶段 把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。***



---



### 快重传和快恢复

- ***快重传算法首先要求接收方每收到一个失序的报 文段后就立即发出重复确认***。这样做可以让发送方及早知道有报文段没有到达接收方。
- ***发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。***
- 不难看出，***快重传并非取消重传计时器***，而是在某些情况下可更早地重传丢失的报文段。

#### 快重传案例

![image-20200926192921025](/assets/imgs/image-20200926192921025.png)

#### 快恢复算法

1. 当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。***但接下去不执行慢开始算法。***
2. ***由于发送方现在认为网络很可能没有发生拥塞， 因此现在不执行慢开始算法，即拥塞窗口cwnd 现在不设置为 1，而是设置为慢开始门 限 ssthresh 减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。***

![image-20200926193026215](/assets/imgs/image-20200926193026215.png)

## 发送窗口的上限值

- 发送方的发送窗口的上限值应当取为***接收方窗口 rwnd 和拥塞窗口 cwnd*** 这两个变量中较小的一个， 即应按以下公式确定:
  $$
  发送窗口的上限值 = Min [rwnd, cwnd] 
  $$

- ***当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。***

- ***当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。***

---



# TCP 的运输连接管理

## 运输连接的三个阶段

- 运输连接就有三个阶段，即:***连接建立、 数据传送和连接释放***。运输连接的管理 就是使运输连接的建立和释放都能正常地进行。
- 连接建立过程中要解决以下三个问题:
  - 要使每一方能够确知对方的存在。
  - 要允许双方协商一些参数(如最大报文段长度，最大窗口大小，服务质量等)。
  - 能够对运输实体资源(如缓存大小，连接表中的项目等)进行分配。

## 客户服务器方式

- ***TCP 连接的建立都是采用客户服务器方式。***
- ***主动发起连接建立的应用进程叫做客户 (client)。***
- ***被动等待连接建立的应用进程叫做服务器(server)。***



## TCP的连接建立

用三次握手建立 TCP 连接:

1. A 的 TCP 向 B 发出连接请求报文段，其首部中的 同步位 SYN = 1，并选择序号 seq = x，表明传送 数据时的第一个数据字节的序号是 x。
2. B的TCP收到连接请求报文段后，如同意，则发回确认。B在确认报文段中应使SYN=1，使ACK=1， 其确认号ack = x + 1，自己选择的序号 seq = y。
3. A收到此报文段后向B给出确认，其ACK=1， 确认号 ack = y + 1。A的TCP通知上层应用进程，连接已经建立。B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程:***TCP 连接已经建立。***

![image-20200926200151407](/assets/imgs/image-20200926200151407.png)

### Q1：为什么两次握手不可以呢？

***为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。***比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。

对于上面这种情况，***如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。***

如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。

### Q2：为什么不需要四次握手？

有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？

***我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。***



---

## TCP 的连接释放

1. 数据传输结束后，通信的双方都可释放连接。 现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A把连接释放报文段首部的FIN=1，其序号 seq = u，等待 B 的确认。
2.  B发出确认，确认号ack = u + 1， 而这个报文段自己的序号 seq = v。TCP服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，***TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。***
3. 若B已经没有要向A发送的数据， 其应用进程就通知 TCP 释放连接。
4. A收到连接释放报文段后，必须发出确认。在确认报文段中ACK = 1，确认号ack = w + 1， 自己的序号seq = u + 1。***TCP 连接必须经过时间 2MSL 后才真正释放掉。***



![image-20200926200446609](/assets/imgs/image-20200926200446609.png)

### Q1：为什么 TIME-WAIT 状态必须等待 2MSL(最长报文寿命) 的时间呢？

1. ***为了保证 A 发送的最后一个 ACK 报文段能够到达 B。***这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。***B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。***接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。

2. ***防止已失效的连接请求报文段出现在本连接中。***A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### Q2：为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?

***当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。***

