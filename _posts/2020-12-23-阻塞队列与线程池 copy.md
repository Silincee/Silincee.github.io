---
layout: post
title:  "二分查找"
date:   2020-04-19 14:10:06 +0800--
categories: [数据结构]
tags: [数据结构, ]  

---

# 前言

之前看了labuladong的二分模版，以为自己懂了，结果遇到题目还是到处吃瘪，各种细节直接痛苦面具放弃思考 😭

最近看到一个讲二分查找的视频，感觉我又行了！特此记录一下该方法，主要思想就是：把红蓝区域固定，然后通过选择返回的r，l获得上界和下界，这样取区域与返回值可以更加灵活多变。

比如 在一段集合里 [1,2,3,5,5,5,8,9] 可以有四种情况 ，要如何进行二分的设计？

1. 找到第一个 `>=5` 的元素 
2. 找到最后一个`<5` 的元素 
3. 找到第一个 `>5 `的元素
4. 找到最后一个 `<=5` 的元素 

![image-20210419104749739](/assets/imgs/image-20210419104749739.png)





# 算法流程

对于一个数组，可以将二分查找任务转换为寻找其 `蓝红边界` ，即求出未知数K-1和K的位置。（target=5）

![image-20210419105129479](/assets/imgs/image-20210419105129479.png)

1）首先整个数组都是灰色的，蓝红指针为别初始化位-1和数组长度length。首先查看数组最中间的元素 `4` 为蓝色，所以将蓝色边界直接扩展到该元素所在位置。

![image-20210419105949499](/assets/imgs/image-20210419105949499.png)

2）继续上述步骤，观察灰色区域中最中间的元素 `6` 为红色，所以将红色指针扩展到该元素所在的位置。

![image-20210419110149133](/assets/imgs/image-20210419110149133.png)

3）一直重复执行上述操作，最后就能够找到蓝红边界：

![image-20210419110252619](/assets/imgs/image-20210419110252619.png)



# 伪代码

- 初始：`l` 指向蓝色区域， `r` 指向红色区域
- 循环： `l` 、 `r`  快速向蓝红边界逼近，**并保持  `l` 、 `r`   颜色不改变**
- 结束： `l` 、 `r`  刚好指向蓝红边界

```java
l = -1, r = N // 首先初始化两个指针，l指向-1，r指向数组长度N
while (l+1 ！= r){ // 循环直至l+1 = r
  m = (l+r)/2 // 求出灰色数组中间元素的位置，并向下取整
  if isBlue(m) l = m // 如果l的颜色为蓝色，就把蓝色区域拓展到m (把 m 赋值给 左指针)
  else r = m // 否则红色区域扩展到m (把m赋值给右指针)
}
return l or r  // 此时的l和r刚刚好指向蓝红边界，可以根据实际情况返回l还是r
```



# 细节问题

> 细节1：为什么 l 的初始值为-1 ，r 的初始值为 N

当l初始化为0的情况下，如果整个数组都是红色，l一开始则会落于红色区域内。r初始化为N-1同理。

![image-20210419133318776](/assets/imgs/image-20210419133318776.png)



> 细节2：m 是否是种处于[0,N)的左闭右开区间以内

只有`m`属于[0,N)的左闭右开区间以内，isBlue(m) 判断颜色才是有意义的。

先来看`m`的下界：因为 `m = (l+r)/2`, 只要让`l`、`r`尽可能的小即可。`l`的最小值即为他的初始值`-1`，对于`r` 而言，如果他能进入循环体，他的最小值为`1`。 因此`m`的最小值即为 `(-1+1)/2=0`。

再来看`m`的上界：要让`l`、`r`尽可能的大即可，`r` 的最大值为 N， `l` 则为N-2 ， `m` 的最大值则为 N-1。

因此 `m` 始终处于于[0,N)的左闭右开区间以内，即`m`不会溢出。

> 细节3：更新指针的时候，能不能写成 l = m +1 或者 r = m - 1

对于下图的情况，在某次循环中`m`刚刚好指向蓝色区域的最后一个元素，如果 `l = m +1` 就会让l指向红色区域造成了错误。` r = m - 1`同理。

![image-20210419134458329](/assets/imgs/image-20210419134458329.png)

> 细节4：程序会不会陷入死循环

无论`l`和`r` 之间隔了多少个元素，都一定会退化到第一种情况并退出循环。

 ![image-20210419135430099](/assets/imgs/image-20210419135430099.png)



# 总结

对于前言中的问题，结合以上分析可归纳出二分查找设计的一般流程：

- 建模：划分蓝红区域，确定 `isBlue()`函数的条件
- 确定返回`l` 还是 `r`
- 套用伪代码模版
- 如果有需要则加入一下后处理逻辑

![image-20210419140058088](/assets/imgs/image-20210419140058088.png)



```java
// case1: 寻找第一个 >=5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right-left)/2 + left;
    if (arr[m]<5){
      left = m;
    }else {
      right = m;
    }

  }
  return right;
}
// case2: 寻找最后一个 <5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right-left)/2 + left;
    if (arr[m]<5){
      left = m;
    }else {
      right = m;
    }

  }
  return left;
}
// case3: 寻找第一个 >5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right-left)/2 + left;
    if (arr[m]<=5){
      left = m;
    }else {
      right = m;
    }

  }
  return right;
}
// case4: 寻找最后一个 <=5 的元素
private int binarySearch(int[] arr) {
  int left = -1;
  int right = arr.length;

  while (left+1!=right){
    int m = (right-left)/2 + left;
    if (arr[m]<=5){
      left = m;
    }else {
      right = m;
    }

  }
  return right;
}
```

