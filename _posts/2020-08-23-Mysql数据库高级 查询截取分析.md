---
scrolllayout: post
title:  "Mysql数据库高级 查询截取分析"
date:   2020-08-23 19:02:06 +0800--
categories: [数据库]
tags: [mysql, ]  
---

# 查询截取分析

## 查询优化

### 小表驱动大表

**优化原则：小表驱动大表，即小的数据集驱动大的数据集**

```sql
---------- 原理(RBO) ---------
select * from A where id in (select id from B)
-- 等价于
for select id from B
for select * from A where A.id = B.id
-- 结论：当 B 表的数据集必须小于 A 表的数据时，用 in 优于 exists

-- exists 写法
select * from A where exists (select 1 from B where B.id = A.id)
-- 等价于
for select * from A
for select * from B where B.id = A.id
-- 结论：当 A 表的数据集小于 B 表的数据集时，用 exists 优于 in
-- 注意：A表和B表的ID字段应建立索引。
```

- EXISTS：SELECT ... FROM table WHERE EXISTRS(subquery)
  - 该语法可以理解为：***将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE）来决定主查询的数据结果是否得以保留。***
  - EXISTS(subquery)只返回TRUE或FALSE，因此子查询中的`SELET * `也可以是`SELECT 1` 或者其他，广发说法是实际执行时会忽略SELECT清淡，因此没有区别
  - EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题
  - EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来替代，何种最优需要具体问题具体分析

### order by 关键字优化

1. order by 子句，尽量使用Index方式排序，避免使用FileSort方式排序

   ```sql
   -- 数据准备：
   create table tblA(
   id int primary key not null auto_increment,
   age int,
   birth timestamp not null
   );
   insert into tblA(age, birth) values(22, now());
   insert into tblA(age, birth) values(23, now());
   insert into tblA(age, birth) values(24, now());
   create index idx_A_ageBirth on tblA(age, birth);
   
   -- 用到了索引，因为带头大哥age都在
   select * from tblA where age>20 order by age;
   select * from tblA where age>20 order by age,birth;
   select * from tblA where birth>'1997-06-27 09:00:00' order by age;
   -- 出现了filesort
   select * from tblA where age>20 order by birth;
   select * from tblA where age>20 order by birth，age;
   select * from tblA order by age asc,birth desc;
   ```

   

2. 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀

3. 如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序

**优化策略**

**总结**

### group by 关键字优化

## 慢日志查询

## 批量数据脚本

## Show profile

## 全局查询日志