---
layout: post
title: "动态代理及其实现原理"
date: 2021-05-23 12:33:16 +0800--
categories: [Java, 设计模式, ]
tags: [代理模式, 设计模式,]  
---

# 代理模式概述

> [代理模式介绍](http://www.silince.cn/2020/09/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F)

代理模式是一种比较好的理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能（开闭原则: 对扩展开放，对修改关闭）。

代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。

代理模式有静态代理和动态代理两种实现方式。





# 静态代理

所谓的静态代理就是在代码**运行之前**，代理类就已经存在，通常情况下， 静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。

静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。



# 动态代理

代理类在程序**运行时**创建的代理方式被成为**动态代理**，也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指令”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB* 动态代理机制）。

动态代理其实是一种方便运行时候动态的处理代理方法的调用机制，通过代理可以让调用者和实现者之间解耦。

从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

**动态代理实现方式：**

- 静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。
- 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)
- 基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术
- 基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）
- 基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） `-javaagent:spring-instrument-4.3.8.RELEASE.jar` （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）





# 参考

- [Java设计模式之结构型模式](http://www.silince.cn/2020/09/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F)

- https://segmentfault.com/a/1190000037648064
- https://cloud.tencent.com/developer/article/1461796



